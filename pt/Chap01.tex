% LaTeX/AMS-LaTeX

\documentclass[a4paper,12pt,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage[portuges]{babel}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[dvips]{graphicx}

\newenvironment{intro}{\sffamily}{\vspace*{2ex minus 1.5ex}}
\newenvironment{code}{\begin{quote}}{\end{quote}}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}

\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt}

\fancypagestyle{plain}{
   \fancyhead{}
   \renewcommand{\headrulewidth}{0pt}
}

\begin{document}

  \chapter{Primeiros passos no Perl}

  \begin{intro}
    \noindent Virtualmente todas linguagens de programa\c{c}\~ao possuem algumas 
    coisas em comum. Os conceitos fundamentais de programa\c{c}\~ao s\~ao os mesmos, 
    n\~ao importa que linguagem voc\^e est\'a utilizando. Neste cap\'itulo vamos 
    investigar o que voc\^e precisa saber antes de iniciar a codifica\c{c}\~ao do programa. 
    Por exemplo:
 
    \begin{itemize}

      \item O que \'e a programa\c{c}\~ao afinal? 

      \item O que significa programar?

      \item O que acontece com o programa que escrevemos?

      \item Como estruturamos os programas e como o constru\'imos de maneira a torna-los de f\'acil compreens\~ao?

      \item Como os computadores v\^e as letras e os n\'umeros?

      \item Como podemos encontrar e eliminar erros nos nossos programas? 

    \end{itemize}

    \noindent Claro que veremos isto da perspectiva do Perl, e vamos analisar alguns
    programas b\'asico em Perl, ver como eles foram constru\'idos e o que fazem. Ao 
    final deste cap\'itulo voc\^e ser\'a convidado a escrever o teu pr\'oprio programa.
  \end{intro}

\section{Linguagens de programa\c{c}\~ao}

  \noindent A primeira pergunta que eu suponho que realmente devemos fazer quando 
  iniciamos o aprendizado sobre programa\c{c}\~ao \'e: "O que \'e programa\c{c}\~ao?".
  Isso pode soar particularmente filos\'ofico, mas a resposta \'e f\'acil. 
  Programa\c{c}\~ao \'e dizer a um computador o que voc\^e quer que ele fa\c{c}a. 
  O \'unico truque, ent\~ao, \'e ter certeza de que o programa \'e escrito de uma forma 
  que o computador possa entender, e para isso, temos de escrever numa l\'{\i}ngua que 
  podemos compreender - uma linguagem de programa\c{c}\~ao, como Perl.\medskip

  \noindent Escrever um programa n\~ao requer habilidades especiais, mas \'e necess\'ario 
  um modo particular de pensar. Quando damos instru\c{c}\~oes para seres humanos, assumimos 
  algumas verdades como certo.

  \begin{itemize}

    \item Humanos questionam quando n\~ao compreendem as instru\c{c}\~oes.

    \item Quebramos tarefas complexas em sub-tarefas.

    \item Podemos tra\c{c}ar paralelos entre a tarefa atual e aqueles que conclu\'{\i}mos no passado.

    \item Talvez mais importante ainda, n\'os podemos aprender a partir de manifesta\c{c}\~oes e de nossos pr\'oprios erros.

  \end{itemize} 

  \noindent Os computadores ainda n\~ao podem fazer qualquer uma dessas coisas 
  muito bem – e ainda \'e muito mais f\'acil explicar a algu\'em como amarrar 
  seus sapatos do que corrigir o rel\'ogio no v\'{\i}deo cassete.\medskip

  \noindent A coisa mais importante que voc\^e precisa ter em mente, por\'em, 
  \'e que voc\^e n\~ao ser\'a capaz de expressar uma tarefa para um computador, 
  se voc\^e n\~ao pode exprimi-la a si mesmo. Programa\c{c}\~ao de computador 
  n\~ao tem espa\c{c}o para especifica\c{c}\~oes vagas. Se voc\^e quiser escrever 
  um programa para, por exemplo, remover arquivos in\'uteis do seu computador, 
  voc\^e precisa ser capaz de explicar a si mesmo como determinar o que \'e um 
  arquivo \'e in\'util ou n\~ao. Voc\^e precisa analisar e detalhar os processos 
  necess\'arios para realizar a tarefa para si mesmo: Voc\^e poderia excluir um 
  arquivo que n\~ao tenha sido acessado por um longo tempo? Quanto tempo, mais 
  precisamente? Apagar o arquivo imediatamente, ou examin\'a-lo? Se voc\^e examin\'a-lo, 
  quanto dele vai examinar? E o que voc\^e examinar\'a?\medskip

\noindent O primeiro passo em programa\c{c}\~ao \'e parar de pensar em "quero um programa 
que remove arquivos in\'uteis", para "eu quero um programa que verifique cada arquivo no 
computador e remova os criados a mais de seis meses e que n\~ao contenha qualquer uma das 
palavras 'Simon', 'Perl' ou 'importantes' nas cincos primeiras linhas". Em outras palavras, 
voc\^e tem de especificar a sua tarefa com precis\~ao.\medskip

\noindent Quando voc\^e for capaz de restruturar a sua pergunta, \'e necess\'ario traduzi-la 
para a linguagem de programa\c{c}\~ao que voc\^e est\'a utilizando. Infelizmente, a linguagem 
de programa\c{c}\~ao n\~ao possui uma rela\c{c}\~ao equivalente direta para o que voc\^e est\'a 
tentando dizer. Ent\~ao, voc\^e ter\'a que desenvolver as tuas atividades utilizando o que a 
linguagem tem a lhe oferecer, o qu\^e significar\'a que voc\^e precisar\'a detalhar (especificar) 
mais ainda a tua tarefa. Por exemplo, n\~ao existe uma maneira de dizer "que n\~ao contenha 
qualquer uma destas palavras nas cincos primeiras linhas" em Perl. No entanto, existe uma maneira 
de dizer "se uma linha cont\'em a palavra", uma maneira de dizer "buscar outra linha", e 
"fa\c{c}a isso cinco vezes". A programa\c{c}\~ao \'e a arte de colocar os elementos juntos para 
fazer o que voc\^e deseja.\medskip

\noindent Existe tantas coisas para voc\^e fazer – mas o que computador faz? Depois termos 
especificado as tarefas em nossa linguagem de programa\c{c}\~ao, o computador pega nossas 
instru\c{c}\~oes e executa-as. Chamamos isto de \textbf{'rodando'} ou \textbf{'executando'} 
o programa. Normalmente, vamos escrever as instru\c{c}\~oes em um arquivo, utilizando um editor 
de texto normal; mas se temos um programa muito pequeno, podemos digit\'a-lo diretamente na 
linha de comando. De qualquer forma, as instru\c{c}\~oes que damos ao computador - no nosso 
caso, escrito em Perl - s\~ao coletivamente chamado de \textbf{c\'odigo fonte} (ou, por vezes, 
apenas \textbf{c\'odigo} ou \textbf{code}) para nosso programa.

\section{Interpretado vs C\'odigo Compilado}

\noindent O que exatamente o computador faz com o nosso c\'odigo fonte, ent\~ao? Tradicionalmente, 
havia duas formas de descrever o que a linguagem de computador fazia com o c\'odigo fonte: Pode-se 
dizer que foram \textbf{compilados}, ou \textbf{interpretados}.\medskip

\noindent Uma linguagem interpretada, como o Basic, precisa de outro programa chamado \textbf{interpretador} 
para processar o c\'odigo fonte cada vez que voc\^e deseja executar o programa. A tradu\c{c}\~ao do c\'odigo 
fonte para a linguagem de m\'aquina \'e demorado. N\'os chamamos de linguagem de baixo n\'{\i}vel, 
ou \textbf{c\'odigo de computador}, porque \'e linguagem para a m\'aquinas ler, j\'a o \textbf{c\'odigo fonte}
\'e para os seres humanos. Enquanto que o c\'odigo fonte parece com o Ingl\^es, por exemplo, 
\texttt{("do\_this() if \$that")}, j\'a o c\'odigo de m\'aquina parece muito mais com algo como por exemplo, 
\texttt{"4576616E67656C6961"}, e esta \'e a vers\~ao leg\'{\i}vel! O c\'odigo de m\'aquina produzida depende 
do processador do computador e do sistema operacional executado, a tradu\c{c}\~ao seria muito diferente de um 
computador x86 executando o Windows NT, em compara\c{c}\~ao com um SUN ou Digital executando Unix.\medskip

\noindent Por outro lado, uma linguagem compilada, como o C, utiliza um compilador que faz todo esse processamento 
de uma única vez antes do c\'odigo ser executado. Depois disso, voc\^e pode executar o c\'odigo de m\'aquina diretamente, 
sem precisar mas do compilador. Porque voc\^e n\~ao precisa processar o c\'odigo fonte cada vez que voc\^e execute-o, 
c\'odigo compilado normalmente ser\'a executado mais r\'apido do que um equivalente interpretado. Voc\^e tamb\'em pode dar 
o c\'odigo compilado para pessoas que n\~ao t\^em um compilador. Isto tamb\'em prevenir\'a que outras pessoas leem
o seu c\'odigo fonte - \'util se voc\^e estiver usando um algoritmo propriet\'ario ou se o seu c\'odigo \'e 
particularmente embara\c{c}oso/vergonhoso. No entanto, porque voc\^e est\'a distribuindo c\'odigo m\'aquina que nem 
todos os tipos de computadores possam compreender, isto n\~ao \'e necessariamente port\'ateis.\medskip

\noindent Recentes linguagens t\^em confundindo a distin\c{c}\~ao compilado/interpretado. Java e Perl, 
ambas linguagem da classe  de "byte-compilados", s\~ao particularmente respons\'aveis pela confus\~ao. 
No caso do Perl, onde o interpretador (que sempre chamamos de \textbf{perl} com "p" min\'usculo) l\^e 
o seu c\'odigo fonte, e o compila inteiro de uma vez. No entanto, em vez de compilar para o c\'odigo 
da m\'aquina que em est\'a executando, ele compila em um c\'odigo especial para uma \textbf{m\'aquina 
virtual (virtual machine)} de um computador fict\'{\i}cio. A "m\'aquina virtual" do Java \'e muito 
parecido com o processador de um computador normal, em rela\c{c}\~ao ao que pode ser feito, e 
pessoas t\^em tentado construir processadores que possa conversar c\'odigo da m\'aquina virtual 
Java "nativamente". Em compara\c{c}\~ao, a m\'aquina virtual do Perl n\~ao \'e muito semelhante 
a qualquer processador de  computador existente e por isto menos suscept\'{\i}vel de ser constru\'{\i}do.\medskip

\noindent Uma vez que temos esse c\'odigo de m\'aquina, o que chamamos \textbf{bytecode}, voc\^e pode 
fazer uma s\'erie de coisas com ele.\medskip

\noindent Voc\^e pode:

\begin{itemize}

 \item Armazena-lo agora para ser executado depois.

 \item Traduzi-lo para o c\'odigo nativo do seu computador, e execut\'a-lo imediatamente.

 \item Execut\'a-lo atrav\'es de um programa que finge ser a m\'aquina virtual e atrav\'es do 
processamento do bytecode, executa as a\c{c}\~oes apropriadas.

\end{itemize}

\noindent N\'os n\~ao fazemos o primeiro item em Perl, embora Java o faz. O "Perl compilador" 
tenta fazer o segundo, mas \'e uma tarefa muito complicada, e ainda n\~ao est\'a completo. 
Normalmente, por\'em, fazemos o terceiro, e assim que o perl terminar de compilar o c\'odigo 
fonte em bytecodes, depois assume o papel de interpretador, traduzindo o c\'odigo da m\'aquina 
virtual para o c\'odigo verdadeiro. Da\'{\i} Perl n\~ao \'e uma linguagem estritamente 
compilada ou interpretada.\medskip

\noindent Algumas pessoas v\~ao dizer \'e que Perl \'e uma linguagem de "script", com a 
conota\c{c}\~ao de que \'e uma linguagem interpretada. Como vimos, isso n\~ao \'e realmente 
verdade. No entanto, esteja ciente de que voc\^e pode ouvir a palavra "script" com a inten\c{c}\~ao 
de "programa".

\section{Bibliotecas, M\'odulos e Pacotes}

\noindent Um monte de gente usa Perl. Uma consequ\^encia disto \'e que, sem surpresa, um monte de 
c\'odigo Perl tem sido escrito. De facto, uma grande parte do c\'odigo Perl que voc\^e necessitar\'a 
escrever provavelmente j\'a tenha sido escrito antes. Para evitar perda de tempo reinventando a roda, 
programadores Perl empacotam seus c\'odigos reutiliz\'aveis e os distribu\'{\i}, principalmente no 
\textbf{CPAN} - a Comprehensive Perl Archive Network - que voc\^e pode encontrar on-line em 
http://www.perl.com/CPAN/.\medskip

\noindent A maior parte do CPAN \'e composto por \textbf{m\'odulos} Perl. Um m\'odulo \'e um 
arquivo ou um conjunto de arquivos que permite realizar uma tarefa. Existe m\'odulo para que 
formatar texto em par\'agrafos, para desenhar gr\'aficos, e at\'e mesmo efetuar o download e 
instalar outros m\'odulos. Seus programas podem utilizar estes m\'odulos e adquirir suas 
funcionalidades. Posteriormente, iremos dedicar a totalidade do Cap\'{\i}tulo 10 para usar, 
instalar, e escrever m\'odulos.\medskip

\noindent Intimamente ligada \'a ideia de um m\'odulo \'e o conceito de \textbf{pacote}, 
que \'e outra maneira de dividir um programa. Ao utilizar pacotes, voc\^e pode ter certeza 
que o que voc\^e faz em uma se\c{c}\~ao do seu programa n\~ao afeta outra se\c{c}\~ao. 
Considerando que um m\'odulo trabalha com um arquivo ou grupo de arquivos no disco, um 
pacote \'e apenas parte do c\'odigo-fonte. Um \'unico arquivo, por exemplo, pode conter 
v\'arios pacotes Inversamente, um pacote pode ser repartido por v\'arios arquivos. Um 
m\'odulo normalmente vive em sua pr\'opria embalagem, isolando o c\'odigo que voc\^e 
escreve fora de interfer\^encia. Novamente, vamos chegar a isso mais tarde no Cap\'{\i}tulo 10.\medskip

\noindent Cada instalação do Perl vem com uma coleção de 'módulos padrão'. O \textbf{padrão}, 
sem surpresa, é o termo para a cole\c{c}ão de arquivos instalados com a distribuição Perl. Às vezes, 
eles também são referenciados como "módulo biblioteca", embora isso possa causar confusão se você 
pretende analisar antigos código Perl: "arquivos de biblioteca" foram usadas em Perl nas versões 
4 e anteriores até serem substituído pelos módulos do Perl 5. Eles são a mesma coisa - pedaços 
de código que você pode usar em seu programa para fazer um trabalho que tem sido feito antes. 
No entanto, eles não têm um "pacote" internamente, e por isso, eles se colocam no mesmo pacote 
do resto do seu programa. Também é bastante simples localizar um arquivo que é seja biblioteca 
e um que seja módulo - a extensão de um arquivo é normalmente .pl, enquanto que a extensão de 
um módulo é \textbf{.pm}.\medskip

\noindent O resultado disto é que o módulo biblioteca pode conter tanto arquivos de biblioteca, 
bem como de módulos, e por isso não é claro sobre qual "biblioteca" é referenciada. A partir de 
agora, quando falarmos de uma "biblioteca", estamos referindo-se à coleção de arquivos distribuídos 
com o Perl, ao invés de arquivos de biblioteca do Perl 4; não vamos fazer qualquer trabalho com 
arquivos de biblioteca (apesar dos arquivos de biblioteca estarem sendo substituídos por módulos, 
eles ainda podem ser úteis), mas iremos utilizar o novo estilo de módulos.

\section{Porque Perl é uma Grande Linaguagem?}

\noindent Perl é utilizado em milhõs de computadores, e é uma das linguagens de programação 
disponível com rápido crescimento. Por que isto ? Já vimos vários motivos para isto na 
introdução, mas acho que vale a pena recordar-las aqui.

\subsection{É realmente fácil}

\noindent Perl não é uma linguagem difícil de aprender. É uma linguagem que tenta moldar-se 
a maneira como as pessoas pensam sobre os problemas e dentro das suas expectativas. Os 
desenvolvedores do Perl acredita que Perl é uma linguagem populista - acessível não 
apenas aos matemáticos e cientistas de computador deste mundo.\medskip

\noindent Eu conheço muitas pessoas científico, ou não, que utilizam Perl com sucesso.

\subsection{Flexibilidade é o nosso lema}

\noindent Perl não quer que você veja as coisas da maneira que o computador faz - não 
é para isto que ele existe. Em vez disso, Perl permite-lhe desenvolver a sua 
abordagem pessoal para programar. Não diria que há certo ou errado para realizar 
o trabalho. Na verdade, é exactamente o oposto - o lema do Perl é \textbf{"Há mais 
de uma maneira de fazer"} (\textbf{"There's more than one way to do it"}), e o Perl 
permite-lhe programar da maneira que faz mais sentido para você.

\subsection{Perl na Web}

\noindent A influência do Perl não é sentida apenas no mundo dos \textit{shell scripters}. 
Não é utilizado apenas em atividades de sysadmin, mas também tem uma enorme importância no 
mundo de \textbf{scripts CGI} para a World Wide Web. Você encontrará Perl automatizando 
a comunicação entre servidores e navegadores de internet de márias maneiras. 
\textbf{Perlscript} é uma (relativamente nova) derivação do Perl em uma linguagem que pode 
ser executada rotinas web tanto do lado do cliente como do servidor, assim como o Javascript 
faz. Como temos dito, no entanto, a principal função do Perl na Internet 
é com as rotinas de scripts CGI.\medskip

\noindent Por algum tempo, CGI foi o padrão para a comunicação entre o servidor web com outros 
programas no servidor, atribuindo aos programas o árduo trabalho da geração de conteúdo 
em páginas web, enquanto o servidor dedica-se a passar esse conteúdo para navegadores o 
mais rápido possível. Claro, páginas web são totalmente baseados em texto, e, graças a 
excelente habilidade na manipulação de texto, PerlCGI tornou-se o padrão na automação de 
servidor web no passado. É ao CGI (e ao Perl) que temos que agradecer as maravilhas páginas 
web dinâmicas estamos habituados na Internet.\medskip

\noindent No capítulo 12, vamos explorar o mundo do CGI em detalhe, e dentre outras coisas, 
veremos como escrever scripts CGI utilizando Perl. No momento, porém, vamos voltar para o 
aprendizado sobre o próprio Perl. Se você quiser dar uma olhada, mais informações sobre PerlCGI 
e PerlScript está disponível em \texttt{www.fastnetltd.ndirect.co.uk/Perl/index.html}.

\subsection{O esfor\c{c}o do código livre (Open Source)}

\noindent Perl é livre. Pertence ao mundo. Larry Wall é o creador da linguagem, claro, mas 
qualquer pessoa no mundo pode baixar, copiar, utilizar e contribuir com melhorias. Aproximadamente 
seiscentas pessoas tiveram o nome registrado no arquivo de alteração (\textit{changes files}) por 
contribuirem na evolução do Perl 4.0 para o Perl 5.0 e para o Perl 5.6, e isto não incluem as 
pessoas que contribuiram com os relatos de problemas para que pudéssemos corrigir.\medskip

\noindent Quando eu digo "qualquer pessoa pode ajudar", não signfica apenas aquelas que 
conhecem todo o código fonte do Perl. Claro, pessoas que possam contribuir no código 
fonte são bem vindos, mas igualmente útil é o trabalho realizado pelo exército de voluntários 
que oferecem seus serviços como testadores, documentadores, revisores entre outros. Qualquer 
pessoa pode contribuir revisando a documenta\c{c}ão, bem como contribuir com uma nova maneira 
de explicar um conceito, ou atravéz de exemplos úteis para uma fun\c{c}ão.\medskip

\noindent O desenvolvimento do Perl é realizado de maneira aberta, na lista de email \textbf{perl5-porters}. 
O programa perlbug, entregue com o Perl, pode ser utilizado para informar problemas 
para a list, mas é uma boa ideia verificar se é realmente o problema e se já não foi 
resolvido na versão mais recente ou na versão em desenvolvimento.

\subsection{Developers Releases and Topaz}

\noindent Perl é uma línguagem viva, e em continua evolu\c{c}ão. O desenvolvimento ocorre em duas frentes:\medskip

\noindent Versão estável do Perl, destinado ao público em geral, possue número de 
versão \textbf{x.y.z} onde o \textbf{z} é menos que 50. Atualmente, estamos na versão 
5.10.0; a próxima grande versão estável será o 5.12.0. Quando o valor de \textbf{z} é 
maior que 0 representa versões de manuten\c{c}ão para corre\c{c}ões de bugs sérios. 
Estas corre\c{c}ões são raros. A versão 5.8, por exemplo, teve 9 manuten\c{c}ões deste Julho de 2002.\medskip

\noindent Durante as versões estáveis, os desenvolvedores trabalham na nova versão do 
Perl, onde o \textbf{y} é ímpar. Quando o 5.10 foi disponibilizado, os trabalhos no 
5.11.0 (a trilha de desenvolvimento) iniciaram para eventualmente se transformar no 
5.12.0. Naturalmente, atualiza\c{c}ões na trilha de desenvolvimento ocorrem com muito 
mais frequência do que ocorre na versão estável, mas não pense que você deverá utilizar 
a versão em desenvolvimento para obter as últimas e melhores características, ou somente 
porquê a tua versão estável do último ano parece antiga em compara\c{c}ão com a novíssima 
e radiante versão do Perl da última semana. Não existem garantias de estabilidade nas 
versões em desenvolvimento.\medskip

\noindent Atualiza\c{c}ões são coordenada pelo(a) mantenedor(a) de corre\c{c}ões (\textbf{patch})
(o(a) controlador(a) de qualidade), que com a ajuda do Larry, decide que contribui\c{c}ões 
serão incluídas e quando, assumindo a ardua responsabilidade de lançar um novo Perl. 
Ele ou ela matém a mais atual e o código oficial do Perl, que em algum momento será 
disponibilizado para o público.\medskip

\noindent \textit{Porque um(a) mantenedor(a) ? Para permitir que as pessoas possam trabalhar 
nas diversas áreas do Perl simultanemante e evitar que duas pessoas alterem a 
mesma área de diferente maneira, uma pessoa precisa tomar a responsábilidade 
sobre qual altera\c{c}ão prevalecerá, e todas as alter\c{c}ões passarão por 
ela. Como a pessoa mantedora é a única que autoriza altera\c{c}ões, Chip 
Salzenburg explica:}\medskip

\noindent \textit{'David Croy disse uma vez que num antigo emprego havia uma 
unidade de backup e vários sistemas que o utilizava para realizar o backup. Mas 
ao invéz de utilizarem um software de alta tecnologia, eles utilizavam um método 
de baixa tecnologia para evitar acessos simultâneos no backup: um mantenendor 
de backup. Ninguém pode fazer backup antes que tenha sido autorizado pelo 
"mantenedor de backup".'}\medskip

\noindent Então o que acontece no desenvolvimento ? Além da corre\c{c}ão de bug, 
os principais objetivos do desenvolvimento é permitir que o Perl seja construído 
com mas facilidade na maior quantidade de computadores e ser mais eficiente na 
utiliza\c{c}ão do sistema operacional e dos hardware existente, como por exemplo 
suporte a processadores de 64-bit. Existe também uma gama de otimiza\c{c}ões a 
serem realizadas, para tornar o Perl mais rápido e eficiente, e trabalhos 
avan\c{c}am para fornecer documentações mais precisas e úteis. Finalmente, 
existem algumas melhorias na sintaxe do Perl que estão em debates - o arquivo 
'\textit{TODO}'\footnote{Atividades a ser realizada} no fonte do Perl explica o que está 
atualmente em evidência.

\subsection{Nosso Primeiro Programa Perl}

\noindent Estou assumindo que neste momento você já possui uma cópia do Perl 
instalado na sua máquina de acordo com as instru\c{c}ões da Introdu\c{c}ão. 
Se for o caso, você está pronto para seguir a frente. Se não for, retorne e 
siga as instru\c{c}ões. Agora crie um diretório para todos os exemplos que 
será utilizado pelo resto do livro e vamos criar nosso primeiro programa Perl.\medskip

\noindent Ele se parece como:

\begin{code}
\texttt{\#!/usr/bin/perl -w}\medskip

\texttt{print "Hello, world.\textbackslash n";}
\end{code}

\noindent O 'Hello World' é exemplo do tradicional encantamento dos deuses para a 
programa\c{c} e garantirá o teu rápido domínio da linguagem, por isso, 
certifique-se de que você realmente completou este exercício, em vez de 
apenas ler sobre ele.\medskip

\noindent Antes de continuarmos, uma breve nota sobre editores. O código 
fonte de programa Perl é texto simples e deve ser escrito com um simples 
editor de texto, ao invéz de um processador de textos. Se você estiver usando 
Windows, você realmente vai querer pesquisar para encontrar um bom editor para 
programador. O \textit{\textbf{Notepad}} ('\textbf{Bloco de nota}') pode ser 
um bom exemplo, apesar da sua irritante tendência de querer renomear extensões 
de arquivo para .pl.txt por você, mas eu não recomendo a sua utilização para 
além disso. \textit{WordPad} também renomeia extensões do arquivo por você e, 
além disso, você deve lembrar-se de salvar como texto simples, não no formato Word. 
\textit{Edit} era suportável, mas já não vem com versões do Windows depois de 95.\medskip

\noindent Um editor decente vai ajudá-lo com suporte à indentação e pode até 
mesmo usar cores diferentes para assinalar diferentes partes do seu código. 
Você certamente desejará visualizar e editar o seu código em uma fonte com 
largura fixa. Os tradicionais editores do mundo Unix, vi, emacs, entre outros 
são perfeitamente adequados, e versões ("portados") destes, estão disponíveis 
para Windows. Quando programo para Windows, pessoalmente utilizo o Open Perl 
IDE (http://open-perl-ide.sourceforge.net). Certo, então, de volta para o código.\medskip

\noindent Após encolher o editor que será utilizado para codificar os teus programas Perl, 
grave o primeiro programa no diretório que será utilizado para o desenvolvimento deste 
livro execute com o comando :\medskip

\noindent $>$\texttt{perl hello1.pl}\medskip

\noindent Se ocorrer tudo bem, aparecerá na tela do seu computador.\medskip

\noindent \texttt{Hello, World.}\medskip

\noindent Parabéns. Você executou com sucesso o teu primeiro código !

\subsubsection{Como isto funciona ?}
\noindent Agora com o teu programa Perl funcionando, vamos ver linha à 
linha como isto ocorre. A primeira linha é:\medskip

\noindent \texttt{\#!/usr/bin/perl}

\noindent Normalmente o Perl trata as linhas que iniciam com \# como
comentário e ignora o restante da linha. S\'o que, o \# junto com o caracterer ! 
no início da primeira linha\footnote{Tecnicamente chamamos os caracteres \#! na primeira linha de um arquivo de shebang}, informa ao Unix\footnote{Isto ocorre em todos os 
sistemas operacionais Unix Like, tal como Linux, *BSD, MAC OS, etc, mas esta 
linha não tem utilidade no ambiente Windows.} como este arquivo deve ser 
executado. Neste caso, o arquivo deverá ser executada utilizando o interpretador 
perl que está localizado no /usr/bin/perl.\medskip

\noindent Perl também lê esta linha, independente se você estiver no Unix, 
Windows, ou outro sistema operacional. Isto ocorre para verificar se existe 
alguma opção especial que deverá ser ligada. No caso da presença do '-w', 
o perl é instruído a ativar informações adicionais de warning\footnote{informação 
importante que pode indicar erros não críticos no código}. A utilização desta 
opção é um hábito recomendável, e nós veremos o motivo logo em seguida, mas 
primeiro vamos avaliar a segunda linha do nosso programa:\medskip

\noindent \texttt{print "Hello, world.\textbackslash n";}\medskip

\noindent A função \texttt{print} diz ao perl para imprimir o texto fornecido, sem as
aspas. O texto dentro das aspas não é interpretado como código (exceto por
alguns 'carecteres especiais') e é conhecido como \textbf{string}.
Como veremos mais tarde, strings são delimitados por alguns tipos de marcação.
O \textbackslash n no final da aspas é um tipo de 'caracter especial' -- um 
tipo de \textit{escape sequence}\footnote{Sequência de caracterer que alteram 
o comportamento normal dos caracteres}, padrão que significa 'nova linha'. Isto 
instrue o perl para finalizar a linha corrente e iniciei o cursor em uma nova linha.\medskip

\noindent Você deve estar curioso porque o -w é tão útil. Bom, supomos que nós 
alteramos nosso programa para demonstratar isto e cometer dois erros,
primeiro excluindo o '-w', e escrever \texttt{printx} ao invés de \texttt{print}. 
Então o hello1.pl ficará assim: 

  \begin{code}
  \texttt{\#!/usr/bin/perl}

  \texttt{print "Hello, world.\textbackslash n";}
  \end{code}

\noindent Lembre-se de gravar estas alterações no arquivo Hello2.pl antes
de sair do arquivo. Agora volte ao console e digite:\medskip

\noindent $>$\texttt{perl hello2.pl}\medskip

\noindent Ao contrário do aguardado\medskip

\noindent Hello, world.

\noindent $>$\medskip

\noindent recebemos como saída uma mensagem de aviso confusa com do tipo:
\begin{verbatim}
String found where operator expected at hello2.pl line 2, near "printx "Hello, world.\n""                                                                                                              
       (Do you need to predeclare printx?)
syntax error at hello2.pl line 2, near "printx "Hello, world.\n""
Execution of hello2.pl aborted due to compilation errors.
\end{verbatim}

\noindent $>$\medskip

\noindent Se corrigirmos um dos nossos erros incluindo o -w no nosso programa, então o hello2.pl ficará assim:\medskip

\begin{code}
  \texttt{\#!/usr/bin/perl -w}\medskip
  \texttt{printx "Hello, world. \textbackslash n";}\medskip
\end{code}

\noindent Assim que gravarmos esta alteração, podemos executar o programa novamente. 
A saída que receberemos agora conterá informações mais precisa sobre o erro, 
então teremos na tela uma mensagem do tipo:\medskip

\noindent $>$\texttt{perl hello2.pl}\medskip

\begin{verbatim}
Unquoted string "printx" may clash with future reserved word at hello2.pl line 2.
String found where operator expected at hello2.pl line 2, near "printx "Hello, world.\n""
       (Do you need to predeclare printx?)
syntax error at hello2.pl line 2, near "printx "Hello, world.\n""
Execution of hello2.pl aborted due to compilation errors.
\end{verbatim}

\noindent A primeira vista, pode parecer que apenas aumentamos o grau de confusão 
da mensagem. Mas tenha em mente que agora a primeira linha contém uma mensagem de
aviso no qual o perl nos informa alguma coisa que pode (ou não) causar problemas 
mais tarde em nosso programa. Neste momento não fique frustado por não compreender 
todas as informações existente na mensagem de erro, agora é mais importante você 
observar a importância de um sistema do alerta.\medskip

\noindent Para versões do Perl 5.6.x e superiores, o parametro -w \textit{pode ser substituído}
com a diretiva \texttt{'use warnings'}, logo depois do \textit{shebang}. 
Apesar do -w ainda ser reconhecida pelo perl, ele foi preterido, 
e para continuar vou assumir que você esteja utilizando a versão do Perl 5.6.x ou superior.
Como resultado, a nova correta versão do nosso programa hello.pl ficará assim:\medskip

\begin{code}
  \texttt{\#!/usr/bin/perl}\medskip
  \texttt{use warnings;}\medskip
  \texttt{print "Hello, world. \textbackslash n";}\medskip
\end{code}


\section{Program Structure}

\noindent 

\noindent One of the things we want to develop throughout this book is a sense of good programming practice. Obviously this will not only benefit you while using Perl, but in almost every other programming language, too. The most fundamental notion is how to structure and lay out the code in your source files. By keeping this tidy and easy to understand, you'll make your own life as a programmer easier.

\noindent 

\noindent \textit{Documenting Your Programs}

\noindent As we saw earlier, a line starting with a sharp (\#) is treated as a comment and ignored. This allows you to provide comments on what your program is doing, something that'll become extremely useful to you when working on long programs or when someone else is looking over your code. For instance, you could make it quite clear what the program above was doing by saying something like this:

\noindent 

\noindent \texttt{\#!/usr/bin/perl}
\noindent \texttt{use warnings;}

\noindent 

\noindent \texttt{\# Print a short message}
\noindent \texttt{print "Hello, world.\textbackslash n";}

\noindent 

\noindent 

\noindent Actually, this isn't the whole story. A line may contain some Perl code, and be followed by a comment.

\noindent This means that we can document our program 'inline' like this:

\noindent 

\noindent 

\noindent \texttt{\#!/usr/bin/perl}
\noindent \texttt{use warnings;}

\noindent 

\noindent \texttt{print "Hello, world.\textbackslash n"; \# Print a short message}

\noindent 

\noindent When we come to write more advanced programs, we'll take a look at some good and bad commenting practice.

\noindent 

\noindent \textit{Keywords}

\noindent There are certain instructions that perl recognizes and understands. The word print above was one such example. On seeing print, perl knew it had to print out to the screen whatever followed in quotes. Words that perl is already aware of are called \textbf{keywords}, and they come in several classes. print is one example of the class called functions. These are the verbs of a programming language, and they tell perl what to do. There are also control keywords, such as if and else. These are used in context like this:

\noindent 

\noindent \texttt{if} Condition;

\noindent do this;

\noindent 

\noindent \texttt{else}

\noindent do this;

\noindent 

\noindent It's a good idea to respect keywords and not reuse them as names. For example, a little later on we'll learn that you can create and name a variable, and that calling your variable \$print is perfectly allowable. The problem with this is that it leads to confusing and uninformative statements like print \$print. It is always a good idea to give a variable a meaningful name, one that relates to its content in a logical manner. For example \$my\_name, \$telephone\_number, @shopping\_list, and so on, rather than \$a, \$b and \%c.

\noindent 

\noindent \textit{Statements and Statement Blocks}

\noindent If functions are the verbs of Perl, then \textbf{statements }are the sentences. Instead of a full stop, a statement in Perl usually ends with a semicolon, as we saw above:

\noindent 

\noindent \texttt{print "Hello, world.\textbackslash n";}

\noindent 

\noindent To print something again, we can add another statement:

\noindent 

\noindent 

\noindent \texttt{print "Hello, world.\textbackslash n";}

\noindent \texttt{print "Goodbye, world.\textbackslash n";}

\noindent 

\noindent There are times when you can get away without adding the semicolon, such as when it's absolutely clear to perl that the statement has finished. However, it is good practice to put a semicolon at the end of each statement. For example, you can miss out the final semicolon in the example above, without causing a problem. Missing out the first would be incorrect.

\noindent 

\noindent We can also group together a bunch of statements into a \textbf{block }-- which is a bit like a paragraph -- by surrounding them with braces: \{\dots \}. We'll see later how blocks are used to specify a set of statements that must happen at a given time and also how they are used to limit the effects of a statement. Here's an example of a block:

\noindent 

\noindent \texttt{\{}

\noindent \texttt{print "This is";}

\noindent \texttt{print "a block";}

\noindent \texttt{print "of statements.\textbackslash n";}

\noindent \texttt{\}}

\noindent 

\noindent Do you notice how I've used indentation to separate the block from its surroundings? This is because, unlike paragraphs, you can put blocks inside of blocks, which makes it easier to see on what level things are happening. This:

\noindent 

\noindent \texttt{print "Top level\textbackslash n";}

\noindent \texttt{\{}

\noindent \texttt{print "Second level\textbackslash n";}

\noindent \texttt{\{}

\noindent \texttt{print "Third level\textbackslash n";}

\noindent \texttt{\}}

\noindent \texttt{print "Where are we?";}

\noindent \texttt{\}}

\noindent 

\noindent is easier to follow than this:

\noindent 

\noindent \texttt{print "Top level\textbackslash n";}

\noindent \texttt{\{}

\noindent \texttt{print "Second level\textbackslash n";}

\noindent \texttt{\{}

\noindent \texttt{print "Third level\textbackslash n";}

\noindent \texttt{\}}

\noindent \texttt{print "Where are we?";}

\noindent \texttt{\}}

\noindent 

\noindent As well as braces to mark out the territory of a block of statements, you can use parentheses to mark out what you're giving a function. We call the set of things you give to a function the \textbf{arguments}, and we say that we \textbf{pass }the arguments to the function. For instance, you can pass a number of arguments to the print function by separating them with commas:

\noindent 

\noindent \texttt{print "here ", "we ", "print ", "several ", "strings.\textbackslash n";}

\noindent 

\noindent The print function happily takes as many arguments as it can, and it gives us the expected answer:

\noindent 

\noindent here we print several strings.

\noindent 

\noindent Surrounding the arguments with brackets clears things up a bit:

\noindent 

\noindent \texttt{print ("here ", "we ", "print ", "several ", "strings.\textbackslash n");}

\noindent 

\noindent We can also limit the amount of arguments we pass by moving the brackets:

\noindent 

\noindent \texttt{print ("here ", "we ", "print "), "several ", "strings.\textbackslash n";}

\noindent 

\noindent We only pass three arguments, so they're the ones that get printed:

\noindent 

\noindent here we print

\noindent 

\noindent What happens to the others? Well, we didn't give perl instructions, so nothing happens.

\noindent 

\noindent In the cases where semicolons or brackets are optional, the important thing to do is to use your judgment. Sometimes code will look perfectly clear without the brackets, but when you've got a complicated statement and you need to be sure of which arguments belong to which function, putting in the brackets can clarify your work. Always aim to help the readers of your code, and remember that these reader will more than likely include you.

\noindent 

\section{ASCII and Unicode}

\noindent 

\noindent Computers are, effectively, lumps of sand and metal. They don't know much about the world. They don't understand words or symbols or letters. They do, however, know how to count. As far as a computer is concerned, everything is a number, and every character, albeit a letter or a symbol, is represented by a number in a sequence. This is called a 'character set', and the character set that computers predominantly use these days is called the 'ASCII' sequence. If you're interested, you can find the complete ASCII character set in Appendix F for reference.

\noindent 

\noindent The ASCII sequence consists of 256 characters, running from character number 0 (all computers, and plenty of computer users, start counting from zero) to character number 255. The letter 'E', for instance, is number 69 in the sequence, and a plus sign (+) is number 43. 255 is a key number for computers and computer programmers alike, because it's the largest number you can store in one 'byte'.

\noindent 

\noindent The big problem with ASCII is that it's American. Well, that's not entirely the problem; the real reason is that it's not particularly useful for people who don't use the Roman alphabet. What used to happen was that particular languages would stick their own alphabet in the upper range of the sequence, between 128 and 255. Of course, we then ended up with plenty of variants that weren't quite ASCII, and the whole point of standardization was lost.

\noindent 

\noindent Worse still, if you've got a language like Chinese or Japanese that has hundreds or thousands of characters, then you really can't fit them into a mere 256. This meant that programmers had to forget about ASCII altogether and build their own systems using pairs of numbers to refer to one character.

\noindent 

\noindent To fix this, \textbf{Unicode }was developed by a number of computer companies, standards organizations, and bibliographic interests. It is currently maintained and developed by the Unicode Consortium, an organization in California. They have also produced a couple of new character sets, UTF8 and UTF16. UTF8 uses two bytes instead of one, so it can contain 65536 characters, which is enough for most people. You can learn more about Unicode at http://www.unicode.org/

\noindent 

\noindent Perl 5.6 introduces Unicode support. Previously, you could print any data that you were capable of producing in your editor or from external sources. However, the functions to translate between lower and upper case wouldn't necessarily work with Greek letters without a lot of support from your operating system. Now, if you have Unicode data, you can consider a single Japanese \textit{kana }to be one character instead of two. So, if you use a Unicode editor for your programming:

\noindent 

\noindent ? You can write your variable names in your native alphabet.

\noindent 

\noindent ? You can match certain classes of symbol or character regardless of language, while processing data.

\noindent 

\subsection{Escape Sequences}

\noindent 

\noindent So, UTF8 gives us 65536 characters, and ASCII gives us 256 characters, but on the average keyboard, there only a hundred or so keys. Even using the shift keys, there will still be some characters that you aren't going to be able to type. There'll also be some things that you don't want to stick in the middle of your program, because they would make it messy or confusing. However, you'll want to refer to some of these characters in strings that you output. Perl provides us with mechanisms called 'escape sequences' as an alternative way of getting to them. We've already seen the use of \textbackslash n to start a new line. Here are the more common escape sequences:

\noindent 

\noindent \textbf{Escape Sequence Meaning}

\noindent 

\noindent \textbackslash t Tab

\noindent 

\noindent \textbackslash n Start a new line (Usually called 'newline')

\noindent 

\noindent \textbackslash b Back up one character ('backspace')

\noindent 

\noindent \textbackslash a Alarm (Rings the system bell)

\noindent 

\noindent \textbackslash x\{1F18\} Unicode character

\noindent

\noindent

\noindent In the last example, 1F18 is a hexadecimal number (see 'Number Systems' just below) referring to a character in the Unicode character set, which runs from 0000-FFFF. As another example, \textbackslash x\{2620\} is the Unicode character for a skull-and-crossbones!

\noindent 

\subsection{White Space}

\noindent White space is the name we give to tabs, spaces, and new lines. Perl is very flexible about where you put white space in your program. We have already seen how we're free to use indentation to help show the structure of blocks. You don't need to use any white space at all, if you don't want to. If you prefer, your programs can all look like this:

\noindent 

\noindent \texttt{print"Top level\textbackslash n";\{print"Second level\textbackslash n";\{print"Third level\textbackslash n";\}print"Where are we?";\}}

\noindent 

\noindent Personally, though, I'd call that a bad idea. White space is another tool we have to make our programs more understandable. Let's use it as such.

\noindent 

\section{Number Systems}

\noindent 

\noindent If you thought the way computers see characters is complicated, we have a surprise for you.

\noindent 

\noindent The way most humans count is using the decimal system, or what we call base 10; we write 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and then when we get to 10, we carry 1 in the 10s column and start from 0 again. Then when the 10s column gets to 9 and the 1s column gets to 9, we carry 1 in the 100s column and start again. Why 10? We used to think it's because we have 10 fingers, but then we discovered that the Babylonians counted up to 60, which stopped that theory.

\noindent 

\noindent On the other hand, computers count by registering whether or not electricity flows in a certain part of the circuit. For simplicity's sake, we'll call a flow of electricity a 1, and no flow a 0. So, we start off with 0, no flow. Then we get a flow, which represents 1. That's as much as we can do with that part of the circuit: 0 or 1, on or off. Instead of base 10, the decimal system, this is \textbf{base 2}, the \textbf{binary system}. In the binary system, one digit represents one unit of information: one binary digit, or \textbf{bit}.

\noindent 

\noindent When we join two parts of the circuit together, things get more interesting. Look at them both in a row, when they are both off, the counter reads 00. Then one comes on, so we get 01. Then what? Well, humans get to 9 and have to carry one to the next column, but computers only get to 1. The next number, number two, is represented as 10. Then 11. And we need some more of our circuit. Number four is 100, 5 is 101, and so ad infinitum. If we got used to it, and we used the binary system naturally, we could count up to 1023 on our fingers.

\noindent 

\noindent This may sound like an abnormal way to count, but even stranger, counting mechanisms are all around us. As I write this, it's 7:59pm. In one minute, it'll be 8:00pm, which seems unremarkable. But that's a base 60 system. In fact, it's worse than that -- time doesn't stay in base 60, because hours carry at 24 instead of 60. Anyone who's used the Imperial measurement system, a Chinese abacus, or pounds, shillings, and pence knows the full horror of mixed base systems, which are far more complicated than what we're dealing with here.

\noindent 

\noindent As well as binary, there are two more important sequences we need to know about when talking to computers. We don't often get to deal with binary directly, but the following two sequences have a logical relationship to base 2 counting. The first is \textbf{octal, base 8}.

\noindent 

\noindent Eight is an important number in computing. Bits are organized in groups of eight to form \textbf{byte}s, giving you the range of 0 to 255 that we saw earlier with ASCII. Each ASCII character can be represented by one byte. As we said in the paragraph before, octal is one way of counting bits -- it has, however, fallen out of fashion these days. Octal numbers all start with 0, (that's a zero, not an oh) so we know they're octal and proceed as you'd expect: 00, 01, 02, 03, 04, 05, 06, 07, carry one, 010, 011, 012\dots 017, carry one, 020 and so on. Perl recognizes octal numbers if you're certain to put that zero in front, like this:

\noindent 

\noindent \texttt{print 01101;}

\noindent 

\noindent \texttt{prints out the decimal number:}

\noindent 

\noindent 577 

\noindent The second is called the \textbf{hexadecimal }system, as mentioned above. Of course, programmers are lazy, so they just call it \textbf{hex}. (They like the wizard image.)

\noindent 

\noindent 

\noindent Decimal is base 10, and hexagons have six sides, so this system is base 16. As you might have guessed from the number 1F18 above, digits above 9 are represented by letters, so A is 10, B is 11, and so on, all the way through to F which is 15. We then carry one and start with 10 (which, in decimal, is 16) all the way up through 19, 1A, 1B, 1C, 1D, 1E, 1F, and carry one again to get 20 (which in decimal is 32). The magic number 255, the maximum number we can store in one byte, is FF. Two bytes next to each other can get you up to FFFF, better known as 65535. We met 65535 as the highest number in the Unicode character set, and you guessed it, a Unicode character can be stored as a pair of bytes.

\noindent 

\noindent To get perl to recognize hex, place 0x in front of the digits so that:

\noindent 

\noindent \texttt{print 0xBEEF;}

\noindent 

\noindent gives the answer:

\noindent 

\noindent 48879 


\noindent 

\subsection{The Perl Debugger}

\noindent 

\noindent One thing you'll notice about programming is that you'll make mistakes; mistakes in programs are called \textbf{bugs}. Bugs are almost entirely unavoidable, and creating bugs does not mean you're a bad programmer. Windows 2000 allegedly shipped with 65,000 bugs (but then that's a special case) and even the greatest programmers in the world have problems with bugs. Donald Knuth's typesetting software TeX has been in use for 18 years, and bugs were still found until a couple of years ago.

\noindent 

\noindent While we will be showing you ways to avoid getting bugs in your program, Perl provides you with a tool to help find and trace the causes of bugs. Naturally, any tool for getting rid of bugs in your program is called a 'debugger'. Mundanely enough, the corresponding tool for putting bugs into your program is called a 'programmer'.

\noindent 

\noindent 

\subsection{Summary}

\noindent 

\noindent We've started on the road to programming in Perl, and programming in general. We've seen our first piece of Perl code, and hopefully, you've had it running. If you haven't, please do get through it and all the examples to come; trying everything yourself is the best way to learn.

\noindent 

\noindent Programming is basically telling a computer what to do in a language it comprehends. It's about breaking down problems or ideas into byte-sized chunks (as it were) and examines the task at hand in order to communicate them clearly to the machine.

\noindent 

\noindent Thankfully, Perl is a language that allows us a certain degree of freedom in our expression, and so long

\noindent as we work within the bounds of the language, it won't enforce any particular method of expression on us. Of course, it may judge what we're saying to be wrong, because we're not speaking the language correctly, and that's how the majority of bugs are born. Generally though, if a program does what we want, that's enough - There's More Than One Way To Do It.

\noindent 

\noindent We've also seen a few ways of making it easy for ourselves to spot potential problems, and we know there are tools that can help us if we need it. We have examined a little bit of what goes on inside a computer, how it sees numbers, and how it sees characters, as well as what it does to our programs when and as it executes them.

\noindent 

\noindent I'm now going to ask you to write a simple program for yourself, nothing strenuous, and nothing harder than we've already seen. But it's important that you take that psychological step into programming right now.

\noindent 

\subsection{Exercises}

\noindent 

\noindent 1.  Look through the documentation installed with your Perl distribution.

\noindent 

\noindent 2.  Create a program newline.plx containing print "Hi Mum.\textbackslash nThis is my second program. \textbackslash n".

\noindent Run this and then to replace \textbackslash n with a space or an Enter and compare the results.

\noindent 

\noindent 3.  Download the code for this book from the wrox website at http://www.wrox.com.

\noindent 

\noindent 4.  Have a look around the Perl homepage at www.perl.com and at our Beginning\_Perl mailing list at http://p2p.wrox.com.

\noindent 

\noindent 

\noindent 

\noindent 

\noindent 

\noindent \includegraphics[bb=0mm 0mm 208mm 296mm, width=185.2mm, height=196.3mm, viewport=3mm 4mm 205mm 292mm]{image7.ps}

\noindent 

\noindent This work is licensed under the Creative Commons Attribution-NoDerivs-NonCommercial License. To view a copy of this

\noindent license, visit http://creativecommons.org/licenses/by-nd-nc/1.0 or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.

\noindent 

\noindent The key terms of this license are:

\noindent 

\noindent Attribution: The licensor permits others to copy, distribute, display, and perform the work. In return, licensees must give the original author credit.

\noindent 

\noindent No Derivative Works: The licensor permits others to copy, distribute, display and perform only unaltered copies of the work -- not derivative works based on it.

\noindent 

\noindent Noncommercial: The licensor permits others to copy, distribute, display, and perform the work. In return, licensees may not use the work for commercial purposes -- unless they get the licensor's permission.


\end{document}

