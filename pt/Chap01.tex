% LaTeX/AMS-LaTeX

\documentclass[a4paper,12pt,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage[portuges]{babel}

% se quiser habilitar Arial
%\renewcommand{\rmdefault}{phv} % Arial
%\renewcommand{\sfdefault}{phv} % Arial

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[dvips]{graphicx}
% Habilita o pacote de url
\usepackage{url}
% define o intro
\newenvironment{intro}{\sffamily}{\vspace*{2ex minus 1.5ex}}

%%============================================================================
%% configura o ambiente para o bloco de código
\usepackage{color}
 \definecolor{Brown}{cmyk}{0,0.81,1,0.60}
  \definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
  \definecolor{CadetBlue}{cmyk}{0.62,0.57,0.23,0}
  \definecolor{lbcolor}{rgb}{1,0.95,1}

\usepackage{listings}
  \lstset{language=Perl}
  \lstset{backgroundcolor=\color{lbcolor}}
  \lstset{keywordstyle=\color{CadetBlue}}
  \lstset{identifierstyle=\color{red}\bfseries}
  \lstset{rulesepcolor=\color{green}}
  \lstset{commentstyle=\color{green}}
  \lstset{numbers=left}
  \lstset{numberstyle=\tiny}
  \lstset{basicstyle=\ttfamily\scriptsize}
%%  \lstset{stringstyle=\ttfamily}
  \lstset{emph={printx}}
  \lstset{emphstyle=\color{black}\bfseries}
  \lstset{numbersep=5pt}
  \lstset{captionpos=b}
  \lstset{columns=fixed}
  \lstset{breaklines=true}
  \lstset{prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}}}
  \lstset{showstringspaces=false}
%%============================================================================
%%============================================================================
%% configuracao das dimensoes da pagina (http://en.wikibooks.org/wiki/LaTeX)

%%============================================================================

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}

\fancyhead[LE,RO]{\bfseries\thepage}
\fancyhead[LO]{\bfseries\rightmark}
\fancyhead[RE]{\bfseries\leftmark}
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0pt}
\addtolength{\headheight}{0.5pt}

\fancypagestyle{plain}{
   \fancyhead{}
   \renewcommand{\headrulewidth}{0pt}
}

\begin{document}

  \chapter{Primeiros passos no Perl}

  \begin{intro}
    \noindent Virtualmente todas linguagens de programa\c{c}\~ao possuem algumas 
    coisas em comum. Os conceitos fundamentais de programa\c{c}\~ao s\~ao os mesmos, 
    n\~ao importa que linguagem voc\^e est\'a utilizando. Neste cap\'itulo vamos 
    investigar o que voc\^e precisa saber antes de iniciar a codifica\c{c}\~ao do programa. 
    Por exemplo:
 
    \begin{itemize}

      \item O que \'e a programa\c{c}\~ao afinal? 

      \item O que significa programar?

      \item O que acontece com o programa que escrevemos?

      \item Como estruturamos os programas e como o constru\'imos de maneira a torna-los de f\'acil compreens\~ao?

      \item Como os computadores v\^e as letras e os n\'umeros?

      \item Como podemos encontrar e eliminar erros nos nossos programas? 

    \end{itemize}

    \noindent Claro que veremos isto da perspectiva do Perl, e vamos analisar alguns
    programas b\'asico em Perl, ver como eles foram constru\'idos e o que fazem. Ao 
    final deste cap\'itulo voc\^e ser\'a convidado a escrever o teu pr\'oprio programa.
  \end{intro}

\section{Linguagens de programa\c{c}\~ao}

  \noindent A primeira pergunta que eu suponho que realmente devemos fazer quando 
  iniciamos o aprendizado sobre programa\c{c}\~ao \'e: ``O que \'e programa\c{c}\~ao?".
  Isso pode soar particularmente filos\'ofico, mas a resposta \'e f\'acil. 
  Programa\c{c}\~ao \'e dizer a um computador o que voc\^e quer que ele fa\c{c}a. 
  O \'unico truque, ent\~ao, \'e ter certeza de que o programa \'e escrito de uma forma 
  que o computador possa entender, e para isso, temos de escrever numa l\'{\i}ngua que 
  podemos compreender - uma linguagem de programa\c{c}\~ao, como Perl.\medskip

  \noindent Escrever um programa n\~ao requer habilidades especiais, mas \'e necess\'ario 
  um modo particular de pensar. Quando damos instru\c{c}\~oes para seres humanos, assumimos 
  algumas verdades como certo.

  \begin{itemize}

    \item Humanos questionam quando n\~ao compreendem as instru\c{c}\~oes.

    \item Quebramos tarefas complexas em sub-tarefas.

    \item Podemos tra\c{c}ar paralelos entre a tarefa atual e aqueles que conclu\'{\i}mos no passado.

    \item Talvez mais importante ainda, n\'os podemos aprender a partir de manifesta\c{c}\~oes e de nossos pr\'oprios erros.

  \end{itemize} 

  \noindent Os computadores ainda n\~ao podem fazer qualquer uma dessas coisas 
  muito bem – e ainda \'e muito mais f\'acil explicar a algu\'em como amarrar 
  seus sapatos do que corrigir o rel\'ogio no v\'{\i}deo cassete.\medskip

  \noindent A coisa mais importante que voc\^e precisa ter em mente, por\'em, 
  \'e que voc\^e n\~ao ser\'a capaz de expressar uma tarefa para um computador, 
  se voc\^e n\~ao pode exprimi-la a si mesmo. Programa\c{c}\~ao de computador 
  n\~ao tem espa\c{c}o para especifica\c{c}\~oes vagas. Se voc\^e quiser escrever 
  um programa para, por exemplo, remover arquivos in\'uteis do seu computador, 
  voc\^e precisa ser capaz de explicar a si mesmo como determinar o que \'e um 
  arquivo \'e in\'util ou n\~ao. Voc\^e precisa analisar e detalhar os processos 
  necess\'arios para realizar a tarefa para si mesmo: Voc\^e poderia excluir um 
  arquivo que n\~ao tenha sido acessado por um longo tempo? Quanto tempo, mais 
  precisamente? Apagar o arquivo imediatamente, ou examin\'a-lo? Se voc\^e examin\'a-lo, 
  quanto dele vai examinar? E o que voc\^e examinar\'a?\medskip

  \noindent O primeiro passo em programa\c{c}\~ao \'e parar de pensar em 
  ``quero um programa que remove arquivos in\'uteis", para ``eu quero um 
  programa que verifique cada arquivo no computador e remova os criados 
  a mais de seis meses e que n\~ao contenha qualquer uma das palavras `Simon', 
  `Perl' ou `importantes' nas cincos primeiras linhas". Em outras palavras, 
  voc\^e tem de especificar a sua tarefa com precis\~ao.\medskip

  \noindent Quando voc\^e for capaz de restruturar a sua pergunta, \'e 
  necess\'ario traduzi-la para a linguagem de programa\c{c}\~ao que 
  voc\^e est\'a utilizando. Infelizmente, a linguagem de programa\c{c}\~ao 
  n\~ao possui uma rela\c{c}\~ao equivalente direta para o que voc\^e est\'a 
  tentando dizer. Ent\~ao, voc\^e ter\'a que desenvolver as tuas atividades 
  utilizando o que a linguagem tem a lhe oferecer, o qu\^e significar\'a que 
  voc\^e precisar\'a detalhar (especificar) mais ainda a tua tarefa. Por 
  exemplo, n\~ao existe uma maneira de dizer ``que n\~ao contenha qualquer 
  uma destas palavras nas cincos primeiras linhas" em Perl. No entanto, 
  existe uma maneira de dizer ``se uma linha cont\'em a palavra", uma 
  maneira de dizer ``buscar outra linha", e ``fa\c{c}a isso cinco vezes". 
  A programa\c{c}\~ao \'e a arte de colocar os elementos juntos para 
  fazer o que voc\^e deseja.\medskip

  \noindent Existe tantas coisas para voc\^e fazer – mas o que computador 
  faz? Depois termos especificado as tarefas em nossa linguagem de programa\c{c}\~ao, 
  o computador pega nossas instru\c{c}\~oes e executa-as. Chamamos isto de 
  \textbf{`rodando'} ou \textbf{`executando'} o programa. Normalmente, vamos 
  escrever as instru\c{c}\~oes em um arquivo, utilizando um editor de texto 
  normal; mas se temos um programa muito pequeno, podemos digit\'a-lo diretamente na 
  linha de comando. De qualquer forma, as instru\c{c}\~oes que damos ao computador
  - no nosso caso, escrito em Perl - s\~ao coletivamente chamado de \textbf{c\'odigo-fonte} 
  (ou, por vezes, apenas \textbf{c\'odigo} ou \textbf{code}) para nosso programa.

\section{Interpretado vs C\'odigo Compilado}

\noindent O que exatamente o computador faz com o nosso c\'odigo-fonte, ent\~ao? Tradicionalmente, 
havia duas formas de descrever o que a linguagem de computador fazia com o c\'odigo-fonte: Pode-se 
dizer que foram \textbf{compilados}, ou \textbf{interpretados}.\medskip

\noindent Uma linguagem interpretada, como o Basic, precisa de outro programa chamado \textbf{interpretador} 
para processar o c\'odigo-fonte cada vez que voc\^e deseja executar o programa. A tradu\c{c}\~ao do c\'odigo 
fonte para a linguagem de m\'aquina \'e demorado. N\'os chamamos de linguagem de baixo n\'{\i}vel, 
ou \textbf{c\'odigo de computador}, porque \'e linguagem para a m\'aquinas ler, j\'a o \textbf{c\'odigo-fonte}
\'e para os seres humanos. Enquanto que o c\'odigo-fonte parece com o Ingl\^es, por exemplo, 
\texttt{("do\_this() if \$that")}, j\'a o c\'odigo de m\'aquina parece muito mais com algo como por exemplo, 
\texttt{"4576616E67656C6961"}, e esta \'e a vers\~ao leg\'{\i}vel! O c\'odigo de m\'aquina produzida depende 
do processador do computador e do sistema operacional executado, a tradu\c{c}\~ao seria muito diferente de um 
computador x86 executando o Windows NT, em compara\c{c}\~ao com um SUN ou Digital executando Unix.\medskip

\noindent Por outro lado, uma linguagem compilada, como o C, utiliza um compilador que faz todo esse processamento 
de uma única vez antes do c\'odigo ser executado. Depois disso, voc\^e pode executar o c\'odigo de m\'aquina diretamente, 
sem precisar mas do compilador. Porque voc\^e n\~ao precisa processar o c\'odigo-fonte cada vez que voc\^e execute-o, 
c\'odigo compilado normalmente ser\'a executado mais r\'apido do que um equivalente interpretado. Voc\^e tamb\'em pode dar 
o c\'odigo compilado para pessoas que n\~ao t\^em um compilador. Isto tamb\'em prevenir\'a que outras pessoas leem
o seu c\'odigo-fonte - \'util se voc\^e estiver usando um algoritmo propriet\'ario ou se o seu c\'odigo \'e 
particularmente embara\c{c}oso/vergonhoso. No entanto, porque voc\^e est\'a distribuindo c\'odigo m\'aquina que nem 
todos os tipos de computadores possam compreender, isto n\~ao \'e necessariamente port\'ateis.\medskip

\noindent Recentes linguagens t\^em confundindo a distin\c{c}\~ao compilado/interpretado. Java e Perl, 
ambas linguagem da classe  de ``byte-compilados", s\~ao particularmente respons\'aveis pela confus\~ao. 
No caso do Perl, onde o interpretador (que sempre chamamos de \textbf{perl} com ``p" min\'usculo) l\^e 
o seu c\'odigo-fonte, e o compila inteiro de uma vez. No entanto, em vez de compilar para o c\'odigo 
da m\'aquina que em est\'a executando, ele compila em um c\'odigo especial para uma \textbf{m\'aquina 
virtual (virtual machine)} de um computador fict\'{\i}cio. A ``m\'aquina virtual" do Java \'e muito 
parecido com o processador de um computador normal, em rela\c{c}\~ao ao que pode ser feito, e 
pessoas t\^em tentado construir processadores que possa conversar c\'odigo da m\'aquina virtual 
Java ``nativamente". Em compara\c{c}\~ao, a m\'aquina virtual do Perl n\~ao \'e muito semelhante 
a qualquer processador de  computador existente e por isto menos suscept\'{\i}vel de ser constru\'{\i}do.\medskip

\noindent Uma vez que temos esse c\'odigo de m\'aquina, o que chamamos \textbf{bytecode}, voc\^e pode 
fazer uma s\'erie de coisas com ele.\medskip

\noindent Voc\^e pode:

\begin{itemize}

 \item Armazena-lo agora para ser executado depois.

 \item Traduzi-lo para o c\'odigo nativo do seu computador, e execut\'a-lo imediatamente.

 \item Execut\'a-lo atrav\'es de um programa que finge ser a m\'aquina virtual e atrav\'es do 
processamento do bytecode, executa as a\c{c}\~oes apropriadas.

\end{itemize}

\noindent N\'os n\~ao fazemos o primeiro item em Perl, embora Java o faz. O ``Perl compilador" tenta 
fazer o segundo, mas \'e uma tarefa muito complicada, e ainda n\~ao est\'a completo. 
Normalmente, por\'em, fazemos o terceiro, e assim que o perl terminar de compilar o c\'odigo 
fonte em bytecodes, depois assume o papel de interpretador, traduzindo o c\'odigo da m\'aquina 
virtual para o c\'odigo verdadeiro. Da\'{\i} Perl n\~ao \'e uma linguagem estritamente 
compilada ou interpretada.\medskip

\noindent Algumas pessoas v\~ao dizer \'e que Perl \'e uma linguagem de ``script", com a 
conota\c{c}\~ao de que \'e uma linguagem interpretada. Como vimos, isso n\~ao \'e realmente 
verdade. No entanto, esteja ciente de que voc\^e pode ouvir a palavra "script" com a inten\c{c}\~ao 
de ``programa".

\section{Bibliotecas, M\'odulos e Pacotes}

\noindent Um monte de gente usa Perl. Uma consequ\^encia disto \'e que, sem surpresa, um monte de 
c\'odigo Perl tem sido escrito. De facto, uma grande parte do c\'odigo Perl que voc\^e necessitar\'a 
escrever provavelmente j\'a tenha sido escrito antes. Para evitar perda de tempo reinventando a roda, 
programadores Perl empacotam seus c\'odigos reutiliz\'aveis e os distribu\'{\i}, principalmente no 
\textbf{CPAN} - a Comprehensive Perl Archive Network - que voc\^e pode encontrar on-line em 
\url{http://www.cpan.org/}.\medskip

\noindent A maior parte do CPAN \'e composto por \textbf{m\'odulos} Perl. Um m\'odulo \'e um 
arquivo ou um conjunto de arquivos que permite realizar uma tarefa. Existe m\'odulo para que 
formatar texto em par\'agrafos, para desenhar gr\'aficos, e at\'e mesmo efetuar o download e 
instalar outros m\'odulos. Seus programas podem utilizar estes m\'odulos e adquirir suas 
funcionalidades. Posteriormente, iremos dedicar a totalidade do Cap\'{\i}tulo 10 para usar, 
instalar, e escrever m\'odulos.\medskip

\noindent Intimamente ligada \'a ideia de um m\'odulo \'e o conceito de \textbf{pacote}, 
que \'e outra maneira de dividir um programa. Ao utilizar pacotes, voc\^e pode ter certeza 
que o que voc\^e faz em uma se\c{c}\~ao do seu programa n\~ao afeta outra se\c{c}\~ao. 
Considerando que um m\'odulo trabalha com um arquivo ou grupo de arquivos no disco, um 
pacote \'e apenas parte do c\'odigo-fonte. Um \'unico arquivo, por exemplo, pode conter 
v\'arios pacotes Inversamente, um pacote pode ser repartido por v\'arios arquivos. Um 
m\'odulo normalmente vive em sua pr\'opria embalagem, isolando o c\'odigo que voc\^e 
escreve fora de interfer\^encia. Novamente, vamos chegar a isso mais tarde no Cap\'{\i}tulo 10.\medskip

\noindent Cada instalação do Perl vem com uma coleção de `módulos padrão'. O \textbf{padrão}, 
sem surpresa, é o termo para a cole\c{c}ão de arquivos instalados com a distribuição Perl. Às vezes, 
eles também são referenciados como ``módulo biblioteca", embora isso possa causar confusão se você 
pretende analisar antigos código Perl: ``arquivos de biblioteca" foram usadas em Perl nas versões 
4 e anteriores até serem substituído pelos módulos do Perl 5. Eles são a mesma coisa - pedaços 
de código que você pode usar em seu programa para fazer um trabalho que tem sido feito antes. 
No entanto, eles não têm um ``pacote" internamente, e por isso, eles se colocam no mesmo pacote 
do resto do seu programa. Também é bastante simples localizar um arquivo que é seja biblioteca 
e um que seja módulo - a extensão de um arquivo é normalmente .pl, enquanto que a extensão de 
um módulo é \textbf{.pm}.\medskip

\noindent O resultado disto é que o módulo biblioteca pode conter tanto arquivos de biblioteca, 
bem como de módulos, e por isso não é claro sobre qual "biblioteca" é referenciada. A partir de 
agora, quando falarmos de uma ``biblioteca", estamos referindo-se à coleção de arquivos distribuídos 
com o Perl, ao invés de arquivos de biblioteca do Perl 4; não vamos fazer qualquer trabalho com 
arquivos de biblioteca (apesar dos arquivos de biblioteca estarem sendo substituídos por módulos, 
eles ainda podem ser úteis), mas iremos utilizar o novo estilo de módulos.

\section{Porque Perl é uma Grande Linaguagem?}

\noindent Perl é utilizado em milhõs de computadores, e é uma das linguagens de programação 
disponível com rápido crescimento. Por que isto ? Já vimos vários motivos para isto na 
introdução, mas acho que vale a pena recordar-las aqui.

\subsection{É realmente fácil}

\noindent Perl não é uma linguagem difícil de aprender. É uma linguagem que tenta moldar-se 
a maneira como as pessoas pensam sobre os problemas e dentro das suas expectativas. Os 
desenvolvedores do Perl acredita que Perl é uma linguagem populista - acessível não 
apenas aos matemáticos e cientistas de computador deste mundo.\medskip

\noindent Eu conheço muitas pessoas científico, ou não, que utilizam Perl com sucesso.

\subsection{Flexibilidade é o nosso lema}

\noindent Perl não quer que você veja as coisas da maneira que o computador faz - não 
é para isto que ele existe. Em vez disso, Perl permite-lhe desenvolver a sua 
abordagem pessoal para programar. Não diria que há certo ou errado para realizar 
o trabalho. Na verdade, é exatamente o oposto - o lema do Perl é \textbf{``Há mais 
de uma maneira de fazer"} (\textit{\textbf{``There's more than one way to do it"}}), e o Perl 
permite-lhe programar da maneira que faz mais sentido para você.

\subsection{Perl na Web}

\noindent A influência do Perl não é sentida apenas no mundo dos \textit{shell scripters}. 
Não é utilizado apenas em atividades de sysadmin, mas também tem uma enorme importância no 
mundo de \textbf{scripts CGI} para a World Wide Web. Você encontrará Perl automatizando 
a comunicação entre servidores e navegadores de internet de márias maneiras. 
\textbf{Perlscript} é uma (relativamente nova) derivação do Perl em uma linguagem que pode 
ser executada rotinas web tanto do lado do cliente como do servidor, assim como o Javascript 
faz. Como temos dito, no entanto, a principal função do Perl na Internet 
é com as rotinas de scripts CGI.\medskip

\noindent Por algum tempo, CGI foi o padrão para a comunicação entre o servidor web com outros 
programas no servidor, atribuindo aos programas o árduo trabalho da geração de conteúdo 
em páginas web, enquanto o servidor dedica-se a passar esse conteúdo para navegadores o 
mais rápido possível. Claro, páginas web são totalmente baseados em texto, e, graças a 
excelente habilidade na manipulação de texto, PerlCGI tornou-se o padrão na automação de 
servidor web no passado. É ao CGI (e ao Perl) que temos que agradecer as maravilhas páginas 
web dinâmicas estamos habituados na Internet.\medskip

\noindent No capítulo 12, vamos explorar o mundo do CGI em detalhe, e dentre outras coisas, 
veremos como escrever scripts CGI utilizando Perl. No momento, porém, vamos voltar para o 
aprendizado sobre o próprio Perl. Se você quiser dar uma olhada, mais informações sobre PerlCGI 
e PerlScript está disponível em \texttt{www.fastnetltd.ndirect.co.uk/Perl/index.html}.

\subsection{O esfor\c{c}o do código livre (Open Source)}

\noindent Perl é livre. Pertence ao mundo. Larry Wall é o creador da linguagem, claro, mas 
qualquer pessoa no mundo pode baixar, copiar, utilizar e contribuir com melhorias. Aproximadamente 
seiscentas pessoas tiveram o nome registrado no arquivo de alteração (\textit{changes files}) por 
contribuirem na evolução do Perl 4.0 para o Perl 5.0 e para o Perl 5.6, e isto não incluem as 
pessoas que contribuiram com os relatos de problemas para que pudéssemos corrigir.\medskip

\noindent Quando eu digo ``qualquer pessoa pode ajudar", não signfica apenas aquelas que 
conhecem todo o código-fonte do Perl. Claro, pessoas que possam contribuir no código 
fonte são bem vindos, mas igualmente útil é o trabalho realizado pelo exército de voluntários 
que oferecem seus serviços como testadores, documentadores, revisores entre outros. Qualquer 
pessoa pode contribuir revisando a documenta\c{c}ão, bem como contribuir com uma nova maneira 
de explicar um conceito, ou atravéz de exemplos úteis para uma fun\c{c}ão.\medskip

\noindent O desenvolvimento do Perl é realizado de maneira aberta, na lista de email \textbf{perl5-porters}. 
O programa perlbug, entregue com o Perl, pode ser utilizado para informar problemas 
para a list, mas é uma boa ideia verificar se é realmente o problema e se já não foi 
resolvido na versão mais recente ou na versão em desenvolvimento.

\subsection{Developers Releases and Topaz}

\noindent Perl é uma línguagem viva, e em continua evolu\c{c}ão. O desenvolvimento ocorre em duas frentes:\medskip

\noindent Versão estável do Perl, destinado ao público em geral, possue número de 
versão \textbf{x.y.z} onde o \textbf{z} é menos que 50. Atualmente, estamos na versão 
5.10.0; a próxima grande versão estável será o 5.12.0. Quando o valor de \textbf{z} é 
maior que 0 representa versões de manuten\c{c}ão para corre\c{c}ões de bugs sérios. 
Estas corre\c{c}ões são raros. A versão 5.8, por exemplo, teve 9 manuten\c{c}ões deste Julho de 2002.\medskip

\noindent Durante as versões estáveis, os desenvolvedores trabalham na nova versão do 
Perl, onde o \textbf{y} é ímpar. Quando o 5.10 foi disponibilizado, os trabalhos no 
5.11.0 (a trilha de desenvolvimento) iniciaram para eventualmente se transformar no 
5.12.0. Naturalmente, atualiza\c{c}ões na trilha de desenvolvimento ocorrem com muito 
mais frequência do que ocorre na versão estável, mas não pense que você deverá utilizar 
a versão em desenvolvimento para obter as últimas e melhores características, ou somente 
porquê a tua versão estável do último ano parece antiga em compara\c{c}ão com a novíssima 
e radiante versão do Perl da última semana. Não existem garantias de estabilidade nas 
versões em desenvolvimento.\medskip

\noindent Atualiza\c{c}ões são coordenada pelo(a) mantenedor(a) de corre\c{c}ões (\textbf{patch})
(o(a) controlador(a) de qualidade), que com a ajuda do Larry, decide que contribui\c{c}ões 
serão incluídas e quando, assumindo a ardua responsabilidade de lançar um novo Perl. 
Ele ou ela matém a mais atual e o código oficial do Perl, que em algum momento será 
disponibilizado para o público.\medskip

\noindent \textit{Porque um(a) mantenedor(a) ? Para permitir que as pessoas possam trabalhar 
nas diversas áreas do Perl simultanemante e evitar que duas pessoas alterem a 
mesma área de diferente maneira, uma pessoa precisa tomar a responsábilidade 
sobre qual altera\c{c}ão prevalecerá, e todas as alter\c{c}ões passarão por 
ela. Como a pessoa mantedora é a única que autoriza altera\c{c}ões, Chip 
Salzenburg explica:}\medskip

\noindent \textit{'David Croy disse uma vez que num antigo emprego havia uma 
unidade de backup e vários sistemas que o utilizava para realizar o backup. Mas 
ao invéz de utilizarem um software de alta tecnologia, eles utilizavam um método 
de baixa tecnologia para evitar acessos simultâneos no backup: um mantenendor 
de backup. Ninguém pode fazer backup antes que tenha sido autorizado pelo 
"mantenedor de backup".'}\medskip

\noindent Então o que acontece no desenvolvimento ? Além da corre\c{c}ão de bug, 
os principais objetivos do desenvolvimento é permitir que o Perl seja construído 
com mas facilidade na maior quantidade de computadores e ser mais eficiente na 
utiliza\c{c}ão do sistema operacional e dos hardware existente, como por exemplo 
suporte a processadores de 64-bit. Existe também uma gama de otimiza\c{c}ões a 
serem realizadas, para tornar o Perl mais rápido e eficiente, e trabalhos 
avan\c{c}am para fornecer documentações mais precisas e úteis. Finalmente, 
existem algumas melhorias na sintaxe do Perl que estão em debates - o arquivo 
'\textit{TODO}'\footnote{Atividades a ser realizada} no fonte do Perl explica o que está 
atualmente em evidência.

\subsection{Nosso Primeiro Programa Perl}

\noindent Estou assumindo que neste momento você já possui uma cópia do Perl 
instalado na sua máquina de acordo com as instru\c{c}ões da Introdu\c{c}ão. 
Se for o caso, você está pronto para seguir a frente. Se não for, retorne e 
siga as instru\c{c}ões. Agora crie um diretório para todos os exemplos que 
será utilizado pelo resto do livro e vamos criar nosso primeiro programa Perl.\medskip

\noindent Ele se parece como:
\begin{lstlisting}
#!/usr/bin/perl -w

print "Hello, world.\n";
\end{lstlisting}

\noindent O `Hello World' é exemplo do tradicional encantamento dos deuses para a 
programa\c{c} e garantirá o teu rápido domínio da linguagem, por isso, 
certifique-se de que você realmente completou este exercício, em vez de 
apenas ler sobre ele.\medskip

\noindent Antes de continuarmos, uma breve nota sobre editores. O código 
fonte de programa Perl é texto simples e deve ser escrito com um simples 
editor de texto, ao invéz de um processador de textos. Se você estiver usando 
Windows, você realmente vai querer pesquisar para encontrar um bom editor para 
programador. O \textit{\textbf{Notepad}} (`\textbf{Bloco de nota}') pode ser 
um bom exemplo, apesar da sua irritante tendência de querer renomear extensões 
de arquivo para .pl.txt por você, mas eu não recomendo a sua utilização para 
além disso. \textit{WordPad} também renomeia extensões do arquivo por você e, 
além disso, você deve lembrar-se de salvar como texto simples, não no formato Word. 
\textit{Edit} era suportável, mas já não vem com versões do Windows depois de 95.\medskip

\noindent Um editor decente vai ajudá-lo com suporte à indentação e pode até 
mesmo usar cores diferentes para assinalar diferentes partes do seu código. 
Você certamente desejará visualizar e editar o seu código em uma fonte com 
largura fixa. Os tradicionais editores do mundo Unix, vi, emacs, entre outros 
são perfeitamente adequados, e versões (``portados") destes, estão disponíveis 
para Windows. Quando programo para Windows, pessoalmente utilizo o Open Perl 
IDE (\url{http://open-perl-ide.sourceforge.net}). Certo, então, de volta para o código.\medskip

\noindent Após encolher o editor que será utilizado para codificar os teus programas Perl, 
grave o primeiro programa no diretório que será utilizado para o desenvolvimento deste 
livro execute com o comando :\medskip

\noindent $>$\texttt{perl hello1.pl}\medskip

\noindent Se ocorrer tudo bem, aparecerá na tela do seu computador.\medskip

\noindent \texttt{Hello, World.}\medskip

\noindent Parabéns. Você executou com sucesso o teu primeiro código !

\subsubsection{Como isto funciona ?}
\noindent Agora com o teu programa Perl funcionando, vamos ver linha à 
linha como isto ocorre. A primeira linha é:\medskip

\noindent \texttt{\#!/usr/bin/perl}

\noindent Normalmente o Perl trata as linhas que iniciam com \# como
comentário e ignora o restante da linha. S\'o que, o \# junto com o caracterer ! 
no início da primeira linha\footnote{Tecnicamente chamamos os caracteres \#! na primeira linha de um arquivo de shebang}, informa ao Unix\footnote{Isto ocorre em todos os 
sistemas operacionais Unix Like, tal como Linux, *BSD, MAC OS, etc, mas esta 
linha não tem utilidade no ambiente Windows.} como este arquivo deve ser 
executado. Neste caso, o arquivo deverá ser executada utilizando o interpretador 
perl que está localizado no /usr/bin/perl.\medskip

\noindent Perl também lê esta linha, independente se você estiver no Unix, 
Windows, ou outro sistema operacional. Isto ocorre para verificar se existe 
alguma opção especial que deverá ser ligada. No caso da presença do `-w', 
o perl é instruído a ativar informações adicionais de warning\footnote{informação 
importante que pode indicar erros não críticos no código}. A utilização desta 
opção é um hábito recomendável, e nós veremos o motivo logo em seguida, mas 
primeiro vamos avaliar a segunda linha do nosso programa:\medskip

\noindent \texttt{print "Hello, world.\textbackslash n";}\medskip

\noindent A função \texttt{print} diz ao perl para imprimir o texto fornecido, sem as
aspas. O texto dentro das aspas não é interpretado como código (exceto por
alguns `carecteres especiais') e é conhecido como \textbf{string}.
Como veremos mais tarde, strings são delimitados por alguns tipos de marcação.
O \textbackslash n no final da aspas é um tipo de `caracter especial' -- um 
tipo de \textit{escape sequence}\footnote{Sequência de caracterer que alteram 
o comportamento normal dos caracteres}, padrão que significa `nova linha'. Isto 
instrue o perl para finalizar a linha corrente e iniciei o cursor em uma nova linha.\medskip

\noindent Você deve estar curioso porque o -w é tão útil. Bom, supomos que nós 
alteramos nosso programa para demonstratar isto e cometer dois erros,
primeiro excluindo o `-w', e escrever \texttt{printx} ao invés de \texttt{print}. 
Então o hello1.pl ficará assim: 

\begin{lstlisting}
#!/usr/bin/perl

print "Hello, world.\n";
\end{lstlisting}


\noindent Lembre-se de gravar estas alterações no arquivo Hello2.pl antes
de sair do arquivo. Agora volte ao console e digite:\medskip

\noindent $>$\texttt{perl hello2.pl}\medskip

\noindent Ao contrário do aguardado\medskip

\noindent Hello, world.

\noindent $>$\medskip

\noindent recebemos como saída uma mensagem de aviso confusa com do tipo:
{\scriptsize
\begin{verbatim}
String found where operator expected at hello2.pl line 2, near "printx "Hello, world.\n""                                                                                                              
       (Do you need to predeclare printx?)
syntax error at hello2.pl line 2, near "printx "Hello, world.\n""
Execution of hello2.pl aborted due to compilation errors.
\end{verbatim}
}\noindent $>$\medskip

\noindent Se corrigirmos um dos nossos erros incluindo o -w no nosso programa, então o hello2.pl ficará assim:\medskip
\begin{lstlisting}
#!/usr/bin/perl -w

printx "Hello, world. \n";
\end{lstlisting}
\noindent Assim que gravarmos esta alteração, podemos executar o programa novamente. 
A saída que receberemos agora conterá informações mais precisa sobre o erro, 
então teremos na tela uma mensagem do tipo:\medskip

\noindent $>$\texttt{perl hello2.pl}\medskip
{\scriptsize
\begin{verbatim}
Unquoted string "printx" may clash with future reserved word at hello2.pl line 2.
String found where operator expected at hello2.pl line 2, near "printx "Hello, world.\n""
       (Do you need to predeclare printx?)
syntax error at hello2.pl line 2, near "printx "Hello, world.\n""
Execution of hello2.pl aborted due to compilation errors.
\end{verbatim}
}
\noindent A primeira vista, pode parecer que apenas aumentamos o grau de confusão 
da mensagem. Mas tenha em mente que agora a primeira linha contém uma mensagem de
aviso no qual o perl nos informa alguma coisa que pode (ou não) causar problemas 
mais tarde em nosso programa. Neste momento não fique frustado por não compreender 
todas as informações existente na mensagem de erro, agora é mais importante você 
observar a importância de um sistema do alerta.\medskip

\noindent Para versões do Perl 5.6.x e superiores, o parametro -w \textit{pode ser substituído}
com a diretiva \texttt{'use warnings'}, logo depois do \textit{shebang}. 
Apesar do -w ainda ser reconhecida pelo perl, ele foi preterido, 
e para continuar vou assumir que você esteja utilizando a versão do Perl 5.6.x ou superior.
Como resultado, a nova correta versão do nosso programa hello.pl ficará assim:\medskip

\begin{lstlisting}
#!/usr/bin/perl
use warnings;

print "Hello, world. \n";
\end{lstlisting}

\section{Estrutura do programa}

\noindent Uma das coisas que queremos desenvolver em todo este livro é o 
senso da boa prática de programação. Obviamente, isso não será útil apenas 
para programar em Perl, mas também para quase todas as outras linguagens 
de programação. A mais fundamental noção é como estruturar e apresentar 
o código nos teus arquivos fontes. Ao manter o código organizado e 
compreensível, você vai deixar a tua vida de programador fácil.\medskip

\subsection{Documente o seu programa}

\noindent Como vimos recentemente, uma linha começando com o cerquilha (\#) é 
tratada como um comentário e ignorada. Isso permite que você faça comentários 
sobre o que o teu programa está fazendo, algo que será extremamente útil quando 
estiver trabalhando em programas longo ou quando alguém estiver analisando 
o teu código. Por exemplo, você poderia deixar o nosso programa mas claro 
sobre o que ele faz comentando algo assim:

\begin{lstlisting}
#!/usr/bin/perl
use warnings;

# Imprime uma mensagem
print "Hello, world. \n";
\end{lstlisting}

\noindent Na verdade, esta não é toda a história. Uma linha pode conter código 
Perl, e em seguida comentário. Isto significa que nós podemos documentar o nosso
programa \textit{`inline'}\footnote{em linha} como no exemplo:

\begin{lstlisting}
#!/usr/bin/perl
use warnings;

print "Hello, world. \n"; # Imprime uma mensagem
\end{lstlisting}

\noindent Quando tivermos escrevendo programas mais avançados, vamos 
dar uma olhada em algumas boas e más práticas de comentar.\medskip

\subsection{Palavras reservadas}

\noindent Existem algumas instruções que o perl reconhece e compreende.
A palavra \texttt{print} é um exemplo. Ao ler a palavra \texttt{print}, 
o perl sabe que precisa imprimir na tela o conteúdo que está demitidado 
entre as aspas. Palavras de conhecimento do perl são chamas de 
\textbf{`palavras reservadas'}\footnote{em inglês o termo é \textbf{keywords}}, 
e existem de diversos tipos. \texttt{print} é um exemplo do tipo chamado 
função\footnote{em inglês o termo é \textbf{function}}. Estas palavras 
são verbos da linguagem de programação, e elas dizem para o perl o quê 
deve ser feito. Existem também palavras de controles, como \texttt{if} 
e \texttt{else}, como são utilizadas em contexto como:\medskip

{\scriptsize
\begin{verbatim}
  if condição;

    se condição verdadeiro, faça isto;

  else

    senão faça aquilo;
\end{verbatim}
}

\noindent É altamente recomendável respeitar as palavras reservadas 
e não as utilizarem para outros fins. Por exemplo, logo em seguida vamos 
aprender a criar e nomear variável, e que nomear a tua variável como 
\texttt{\$print} é perfeitamente permitido. O problema é que isto leva 
a confusão em declarações como \texttt{print \$print}. É sempre uma boa 
idéia dar a variável um nome significativo, um que se relaciona com o 
conteúdo de uma forma lógica.Por exemplo \texttt{\$meu\_nome}, \texttt{\$telefone\_numero}, 
\texttt{@list\_compras}, e assim por diante, ao vez de \texttt{\$a}, \texttt{\$b} 
e \texttt{\%c}.\medskip

\noindent \textit{Instruções e Blocos de Instrução}

\noindent Se as funções são os verbos de Perl, então \textbf{instruções (statements) } são as 
as sentenças. Em vez de um ponto, uma instrução em Perl normalmente termina
com um ponto e vírgula, como vimos abaixo:\medskip

\noindent 

\noindent \texttt{print "Hello, world.\textbackslash n";}

\noindent 

\noindent Para imprimir alguma coisa novamente, então nós escrevemos outra instrução:

\noindent 

\noindent 

\noindent \texttt{print "Hello, world.\textbackslash n";}

\noindent \texttt{print "Goodbye, world.\textbackslash n";}

\noindent 

\noindent Há momentos em que você pode ir longe sem adicionar o ponto e vírgula, 
como quando é absolutamente claro para o perl quando a instrução foi concluída. 
No entanto, é boa prática colocar o ponto e vírgula no final de cada instrução. 
Por exemplo, você pode perder o ponto e vírgula final do exemplo acima, sem causar problema. 
Perdendo a primeira seria incorreto.\medskip

\noindent 

\noindent Podemos agrupar um conjunto de instruções num  
\textbf{bloco }-- tal como um parágrafo -- delimitando com chaves: \{\dots \}. 
Veremos mais tarde como os blocos são usados para especificar um conjunto de 
instruções que deve acontecer em um determinado momento e também como eles são 
usados para limitar os efeitos de uma declaração. Aqui está um exemplo de um bloco:

\noindent 

\noindent \texttt{\{}

\noindent \texttt{print "This is";}

\noindent \texttt{print "a block";}

\noindent \texttt{print "of statements.\textbackslash n";}

\noindent \texttt{\}}

\noindent 

\noindent Você observou como utilizamos os recuos (ou identação) para separar os blocos? 
Isto porque, ao contrário dos paragrafos, você pode colocar blocos dentro de blocos,
o que torna mais fácil ver em que nível as coisas estão acontecendo. Este:

\noindent 

\noindent \texttt{print "Top level\textbackslash n";}

\noindent \texttt{\{}

\noindent \texttt{print "Second level\textbackslash n";}

\noindent \texttt{\{}

\noindent \texttt{print "Third level\textbackslash n";}

\noindent \texttt{\}}

\noindent \texttt{print "Where are we?";}

\noindent \texttt{\}}

\noindent 

\noindent é mais fácil do quê:

\noindent 

\noindent \texttt{print "Top level\textbackslash n";}

\noindent \texttt{\{}

\noindent \texttt{print "Second level\textbackslash n";}

\noindent \texttt{\{}

\noindent \texttt{print "Third level\textbackslash n";}

\noindent \texttt{\}}

\noindent \texttt{print "Where are we?";}

\noindent \texttt{\}}

\noindent 

\noindent Bem como as chaves são utilizadas para demarcar o território de um bloco de instruções, 
você pode usar parênteses para marcar o que você está fornecendo a uma função. 
Chamamos o conjunto de coisas que você dá para uma função de \textbf{argumentos}, 
e dizemos que \textbf{passamos} os argumentos para a função. Por exemplo, você pode 
passar uma série de argumentos para a função \textit{print}, separando-os 
com vírgulas:


\noindent 

\noindent \texttt{print "here ", "we ", "print ", "several ", "strings.\textbackslash n";}

\noindent 

\noindent A função \textit{print} recebe todos os argumentos fornecido, e retorna a resposta desejada:

\noindent 

\noindent here we print several strings.

\noindent 

\noindent Delimitar os argumentos com parênteses torna as coisas mais claras :

\noindent 

\noindent \texttt{print ("here ", "we ", "print ", "several ", "strings.\textbackslash n");}

\noindent 

\noindent Também podemos limitar a quantidade de argumentos que passamos movendo parênteses:

\noindent 

\noindent \texttt{print ("here ", "we ", "print "), "several ", "strings.\textbackslash n";}

\noindent 

\noindent Nos passamos apenas três argumentos, então o resultado que teremos:

\noindent 

\noindent here we print

\noindent 

\noindent O que ocorreu com os outros? Bem, nós não passamos as instruções, então nada ocorreu.

\noindent 

\noindent Nos casos em que ponto e a vírgula ou parênteses são opcionais, a 
coisa  mais importante a fazer é usar o seu julgamento. Às vezes, o código ficará 
perfeitamente claro, sem os parênteses, mas quando você tem uma instrução 
complexa e você precisa ter certeza de quais argumentos pertencem a qual 
função, utilizar os parênteses pode esclarecer o seu trabalho. Sempre 
com objectivo de facilitar a leitura do seu código, e lembre-se 
que estes leitor mais do que provavelmente inclui você.

\noindent 

\section{ASCII and Unicode}

\noindent 

\noindent Computers are, effectively, lumps of sand and metal. 
They don't know much about the world. They don't understand words 
or symbols or letters. They do, however, know how to count. As far 
as a computer is concerned, everything is a number, and every character, 
albeit a letter or a symbol, is represented by a number in a sequence. 
This is called a 'character set', and the character set that computers 
predominantly use these days is called the 'ASCII' sequence. If you're 
interested, you can find the complete ASCII character set in 
Appendix F for reference.

\noindent 

\noindent The ASCII sequence consists of 256 characters, running from 
character number 0 (all computers, and plenty of computer users, start 
counting from zero) to character number 255. The letter 'E', for instance, 
is number 69 in the sequence, and a plus sign (+) is number 43. 255 is a 
key number for computers and computer programmers alike, because it's the 
largest number you can store in one 'byte'.

\noindent 

\noindent The big problem with ASCII is that it's American. Well, that's 
not entirely the problem; the real reason is that it's not particularly 
useful for people who don't use the Roman alphabet. What used to happen 
was that particular languages would stick their own alphabet in the upper 
range of the sequence, between 128 and 255. Of course, we then ended up 
with plenty of variants that weren't quite ASCII, and the whole point of 
standardization was lost.

\noindent 

\noindent Worse still, if you've got a language like Chinese or Japanese 
that has hundreds or thousands of characters, then you really can't fit 
them into a mere 256. This meant that programmers had to forget about 
ASCII altogether and build their own systems using pairs of numbers to 
refer to one character.

\noindent 

\noindent To fix this, \textbf{Unicode }was developed by a number of computer 
companies, standards organizations, and bibliographic interests. It is currently 
maintained and developed by the Unicode Consortium, an organization in California. 
They have also produced a couple of new character sets, UTF8 and UTF16. UTF8 uses 
two bytes instead of one, so it can contain 65536 characters, which is enough for 
most people. You can learn more about Unicode at http://www.unicode.org/

\noindent 

\noindent Perl 5.6 introduces Unicode support. Previously, you could print any 
data that you were capable of producing in your editor or from external sources. 
However, the functions to translate between lower and upper case wouldn't necessarily 
work with Greek letters without a lot of support from your operating system. Now, 
if you have Unicode data, you can consider a single Japanese \textit{kana }to be 
one character instead of two. So, if you use a Unicode editor for your programming:

\noindent 

\noindent ? You can write your variable names in your native alphabet.

\noindent 

\noindent ? You can match certain classes of symbol or character regardless of language, while processing data.

\noindent 

\subsection{Escape Sequences}

\noindent 

\noindent So, UTF8 gives us 65536 characters, and ASCII gives us 256 characters, but 
on the average keyboard, there only a hundred or so keys. Even using the shift keys, 
there will still be some characters that you aren't going to be able to type. There'll 
also be some things that you don't want to stick in the middle of your program, because 
they would make it messy or confusing. However, you'll want to refer to some of these 
characters in strings that you output. Perl provides us with mechanisms called 'escape 
sequences' as an alternative way of getting to them. We've already seen the use of 
\textbackslash n to start a new line. Here are the more common escape sequences:

\noindent 

\noindent \textbf{Escape Sequence Meaning}

\noindent 

\noindent \textbackslash t Tab

\noindent 

\noindent \textbackslash n Start a new line (Usually called 'newline')

\noindent 

\noindent \textbackslash b Back up one character ('backspace')

\noindent 

\noindent \textbackslash a Alarm (Rings the system bell)

\noindent 

\noindent \textbackslash x\{1F18\} Unicode character

\noindent

\noindent

\noindent In the last example, 1F18 is a hexadecimal number (see 'Number Systems' just below) referring to a character in the Unicode character set, which runs from 0000-FFFF. As another example, \textbackslash x\{2620\} is the Unicode character for a skull-and-crossbones!

\noindent 

\subsection{White Space}

\noindent White space is the name we give to tabs, spaces, and new lines. Perl is very flexible about where you put white space in your program. We have already seen how we're free to use indentation to help show the structure of blocks. You don't need to use any white space at all, if you don't want to. If you prefer, your programs can all look like this:

\noindent 

\noindent \texttt{print"Top level\textbackslash n";\{print"Second level\textbackslash n";\{print"Third level\textbackslash n";\}print"Where are we?";\}}

\noindent 

\noindent Personally, though, I'd call that a bad idea. White space is another tool we have to make our programs more understandable. Let's use it as such.

\noindent 

\section{Number Systems}

\noindent 

\noindent If you thought the way computers see characters is complicated, we have a surprise for you.

\noindent 

\noindent The way most humans count is using the decimal system, or what we call base 10; we write 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and then when we get to 10, we carry 1 in the 10s column and start from 0 again. Then when the 10s column gets to 9 and the 1s column gets to 9, we carry 1 in the 100s column and start again. Why 10? We used to think it's because we have 10 fingers, but then we discovered that the Babylonians counted up to 60, which stopped that theory.

\noindent 

\noindent On the other hand, computers count by registering whether or not electricity flows in a certain part of the circuit. For simplicity's sake, we'll call a flow of electricity a 1, and no flow a 0. So, we start off with 0, no flow. Then we get a flow, which represents 1. That's as much as we can do with that part of the circuit: 0 or 1, on or off. Instead of base 10, the decimal system, this is \textbf{base 2}, the \textbf{binary system}. In the binary system, one digit represents one unit of information: one binary digit, or \textbf{bit}.

\noindent 

\noindent When we join two parts of the circuit together, things get more interesting. Look at them both in a row, when they are both off, the counter reads 00. Then one comes on, so we get 01. Then what? Well, humans get to 9 and have to carry one to the next column, but computers only get to 1. The next number, number two, is represented as 10. Then 11. And we need some more of our circuit. Number four is 100, 5 is 101, and so ad infinitum. If we got used to it, and we used the binary system naturally, we could count up to 1023 on our fingers.

\noindent 

\noindent This may sound like an abnormal way to count, but even stranger, counting mechanisms are all around us. As I write this, it's 7:59pm. In one minute, it'll be 8:00pm, which seems unremarkable. But that's a base 60 system. In fact, it's worse than that -- time doesn't stay in base 60, because hours carry at 24 instead of 60. Anyone who's used the Imperial measurement system, a Chinese abacus, or pounds, shillings, and pence knows the full horror of mixed base systems, which are far more complicated than what we're dealing with here.

\noindent 

\noindent As well as binary, there are two more important sequences we need to know about when talking to computers. We don't often get to deal with binary directly, but the following two sequences have a logical relationship to base 2 counting. The first is \textbf{octal, base 8}.

\noindent 

\noindent Eight is an important number in computing. Bits are organized in groups of eight to form \textbf{byte}s, giving you the range of 0 to 255 that we saw earlier with ASCII. Each ASCII character can be represented by one byte. As we said in the paragraph before, octal is one way of counting bits -- it has, however, fallen out of fashion these days. Octal numbers all start with 0, (that's a zero, not an oh) so we know they're octal and proceed as you'd expect: 00, 01, 02, 03, 04, 05, 06, 07, carry one, 010, 011, 012\dots 017, carry one, 020 and so on. Perl recognizes octal numbers if you're certain to put that zero in front, like this:

\noindent 

\noindent \texttt{print 01101;}

\noindent 

\noindent \texttt{prints out the decimal number:}

\noindent 

\noindent 577 

\noindent The second is called the \textbf{hexadecimal }system, as mentioned above. Of course, programmers are lazy, so they just call it \textbf{hex}. (They like the wizard image.)

\noindent 

\noindent 

\noindent Decimal is base 10, and hexagons have six sides, so this system is base 16. As you might have guessed from the number 1F18 above, digits above 9 are represented by letters, so A is 10, B is 11, and so on, all the way through to F which is 15. We then carry one and start with 10 (which, in decimal, is 16) all the way up through 19, 1A, 1B, 1C, 1D, 1E, 1F, and carry one again to get 20 (which in decimal is 32). The magic number 255, the maximum number we can store in one byte, is FF. Two bytes next to each other can get you up to FFFF, better known as 65535. We met 65535 as the highest number in the Unicode character set, and you guessed it, a Unicode character can be stored as a pair of bytes.

\noindent 

\noindent To get perl to recognize hex, place 0x in front of the digits so that:

\noindent 

\noindent \texttt{print 0xBEEF;}

\noindent 

\noindent gives the answer:

\noindent 

\noindent 48879 


\noindent 

\subsection{The Perl Debugger}

\noindent 

\noindent One thing you'll notice about programming is that you'll make mistakes; mistakes in programs are called \textbf{bugs}. Bugs are almost entirely unavoidable, and creating bugs does not mean you're a bad programmer. Windows 2000 allegedly shipped with 65,000 bugs (but then that's a special case) and even the greatest programmers in the world have problems with bugs. Donald Knuth's typesetting software TeX has been in use for 18 years, and bugs were still found until a couple of years ago.

\noindent 

\noindent While we will be showing you ways to avoid getting bugs in your program, Perl provides you with a tool to help find and trace the causes of bugs. Naturally, any tool for getting rid of bugs in your program is called a 'debugger'. Mundanely enough, the corresponding tool for putting bugs into your program is called a 'programmer'.

\noindent 

\noindent 

\subsection{Summary}

\noindent 

\noindent We've started on the road to programming in Perl, and programming in general. We've seen our first piece of Perl code, and hopefully, you've had it running. If you haven't, please do get through it and all the examples to come; trying everything yourself is the best way to learn.

\noindent 

\noindent Programming is basically telling a computer what to do in a language it comprehends. It's about breaking down problems or ideas into byte-sized chunks (as it were) and examines the task at hand in order to communicate them clearly to the machine.

\noindent 

\noindent Thankfully, Perl is a language that allows us a certain degree of freedom in our expression, and so long

\noindent as we work within the bounds of the language, it won't enforce any particular method of expression on us. Of course, it may judge what we're saying to be wrong, because we're not speaking the language correctly, and that's how the majority of bugs are born. Generally though, if a program does what we want, that's enough - There's More Than One Way To Do It.

\noindent 

\noindent We've also seen a few ways of making it easy for ourselves to spot potential problems, and we know there are tools that can help us if we need it. We have examined a little bit of what goes on inside a computer, how it sees numbers, and how it sees characters, as well as what it does to our programs when and as it executes them.

\noindent 

\noindent I'm now going to ask you to write a simple program for yourself, nothing strenuous, and nothing harder than we've already seen. But it's important that you take that psychological step into programming right now.

\noindent 

\subsection{Exercises}

\noindent 

\noindent 1.  Look through the documentation installed with your Perl distribution.

\noindent 

\noindent 2.  Create a program newline.plx containing print "Hi Mum.\textbackslash nThis is my second program. \textbackslash n".

\noindent Run this and then to replace \textbackslash n with a space or an Enter and compare the results.

\noindent 

\noindent 3.  Download the code for this book from the wrox website at http://www.wrox.com.

\noindent 

\noindent 4.  Have a look around the Perl homepage at www.perl.com and at our Beginning\_Perl mailing list at http://p2p.wrox.com.

\noindent 

\noindent 

\noindent 

\noindent 

\noindent 

\noindent \includegraphics[bb=0mm 0mm 208mm 296mm, width=185.2mm, height=196.3mm, viewport=3mm 4mm 205mm 292mm]{image7.ps}

\noindent 

\noindent This work is licensed under the Creative Commons Attribution-NoDerivs-NonCommercial License. To view a copy of this

\noindent license, visit http://creativecommons.org/licenses/by-nd-nc/1.0 or send a letter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.

\noindent 

\noindent The key terms of this license are:

\noindent 

\noindent Attribution: The licensor permits others to copy, distribute, display, and perform the work. In return, licensees must give the original author credit.

\noindent 

\noindent No Derivative Works: The licensor permits others to copy, distribute, display and perform only unaltered copies of the work -- not derivative works based on it.

\noindent 

\noindent Noncommercial: The licensor permits others to copy, distribute, display, and perform the work. In return, licensees may not use the work for commercial purposes -- unless they get the licensor's permission.


\end{document}

